# HA package built Mon Jan 25 19:51:06 2016
if echo '
' | od -b | grep -q 015 ; then echo dos format script - exiting ; exit 0 ; fi ; true
# This is a shell archive.  Save it in a file, remove anything before
# this line, and then unpack it by entering "sh file".  Note, it may
# create directories; files and directories will be owned by you and
# have default permissions.
#
# This archive contains:
#
#	README
#	Makefile
#	appdcontroller-db.sh
#	appdcontroller.sh
#	assassin.sh
#	failover.sh
#	watchdog.sh
#	install-init.sh
#	uninstall-init.sh
#	watchdog.settings.template
#	replicate.sh
#	install-init.sh
#	uninstall-init.sh
#	appdservice.c
#	appdservice-pbrun.sh
#	appdservice-root.sh
#	hafunctions.sh
#	RUNBOOK
#
echo x - README
sed 's/^X//' >README << 'END-of-README'
XContents:
X
X	README: this file
X	RUNBOOK:  a list of state descriptions, validations, and remedial actions
X
X
X	replicate.sh:  the all-singing, all-dancing HA (re)activator
X	this installs and sets up the HA function for a controller pair.
X
X	appdcontroller.sh: a file intended to be placed into /etc/init.d to control
X	the controller, watchdog, and assassin
X
X	appdcontroller-db.sh: a file intended to be placed into /etc/init.d to control
X	the mysql database
X
X	assassin.sh:  a script run on a failed-over primary to kill the old primary
X
X	failover.sh:  a script run on a secondary to become the new primary
X
X	install-init.sh:  an installer for the appdcontroller.sh
X
X	uninstall-init.sh:  an uninstaller for the appdcontroller.sh
X
X	watchdog.sh:  run on a secondary to watch the primary and maybe failover
X
X	watchdog.settings.template:  copy this to watchdog.settings to override defaults
X
X	appdservice-root.sh:  a null privilege escalation wrapper
X
X	appdservice-pbrun.sh:  a privilege escalation wrapper around pbrun
X
X	appdservice.c:  a privilege escalation c program
X	
XInstallation notes:
XThis software is intended to connect the appdynamics controller into linux's
Xservice machinery.  This optionally includes a watchdog process running on the
Xsecondary HA node that will initiate a failover if a failure is detected in
Xthe primary controller or database.
X
XPermissions: 
X	If the controller is to be run as a non-root user, part of the 
Xinstallation cannot be directly automated, as it involves installing of a 
Xsystem service into /etc/init.d and ancillary directories using install-init.sh
X
XPrerequisites:
X--------------
X	1) Ssh must be installed in such a way that the user the controller is to 
Xbe run as has symmetrical passwordless ssh access.  This is done by generating 
Xa key pair on each node, and placing the other's public key into the appropriate
Xauthorized_keys file.  in detail, assuming user appduser, node1 and node2
X
X	on node1:
X
X	su - appduser
X	mkdir -p .ssh
X	ssh-keygen -t rsa -N "" -f .ssh/id_rsa
X	scp .ssh/id_rsa.pub node2:/tmp
X
X	on node2:
X
X	su - appduser
X	mkdir -p .ssh
X	ssh-keygen -t rsa -N "" -f .ssh/id_rsa
X	cat /tmp/id_rsa.pub >> .ssh/authorized_keys
X	scp .ssh/id_rsa.pub node1:/tmp
X
X	on node1:
X	cat /tmp/id_rsa.pub >> ~/.ssh/authorized_keys
X
XAll of the above commands may not be needed, and some of them may prompt for a
Xpassword.
X
X	2) reliable symmetrical reverse host lookup must be configured.  the best
Xway is to place the host names into each /etc/hosts file.   reverse DNS adds 
Xan additional point of failure.  
X		a) /etc/nsswitch.conf should have files placed before dns. example:
X			hosts:      files dns
X		b) /etc/hosts:
X			192.168.144.128 host1
X			192.168.144.137 host2
X
X	3) each machine must have the root and data directory writable by the 
Xappropriate appdynamics user:
X
X	ls -lad /opt/AppDynamics/Controller
Xdrwxr-xr-x. 18 appduser users    4096 Jan 26 18:18 /opt/AppDynamics/Controller
X
X	4) the primary controller should be installed as a standalone controller;
Xthe secondary should not be installed at all.
X
XInstallation:
X-------------
XOn the primary, unpack the shar file using bash into a directory HA under the 
Xcontroller root install subdirectory.
X
X	cd /opt/AppDynamics/Controller
X	mkdir -p HA
X	chmod +w *
X	bash HA.shar
X
XActivation:
X-----------
XThe key script to replicate the primary database to the secondary, make all the
Xappropriate state changes, and activate the HA pair is the replicate.sh script.
Xit is run on an active controller.  Attempts to run it on a passive controller 
Xwill be rejected.  it has a few specialized options, but it has reasonable
Xdefaults and is extracts a lot of configuration information from the existing
Xinstallation.  the most simple usage is to activate a HA pair immediately.
Xrun the following as the same user as appdynamics is running as.
Xsince the controller is taken down, the command will prompt for a confirmation message.
X
X	./replicate.sh -s node2 -f -w -e proxy
X
Xwhen it has completed, the HA pair will be running and replicating.
XIf running as non-root, the command asks that some commands manually be run as
Xroot to complete the installation.
X
XIncremental Activation:
X-----------------------
XRuns of the replicate script without the -f option will perform an imperfect 
Xcopy of the primary controller to the secondary without taking the primary down.
XThis can be used to minimize the downtime necessary to do the initial 
Xinstallation.  if the data volume to replicate is large, several runs without
Xthe -f option would approach a perfect copy over a period of days.  the final
Xactivation with -f during a maintenance window would only copy those data filesi
Xthat differ from the last copy.
X
XPrivilege Escalation:
X---------------------
Xthe install-init.sh script is used to install the init scripts, and to set
Xup a controlled privilege escalation.  this can take the form of sudo settings,
Xor one of 3 flavors of /sbin/appdservice. run install-init.sh for usage.
X
XService Control:
X----------------
XAfter activation, the controller service and HA facility can be controlled 
Xusing the linux service command.  these options must be executed as root.
XThe default installation will automatically shut down the controller when
Xthe system is halted, and automatically start it at boot time.
X
X	service appdcontroller start
X	service appdcontroller stop
X
Xan additional service, appdcontroller-db, is used to manage the database.
Xa sensible dependency between the two services is implemented
X
XStatus:
X-------
XOnce installed as a service, the linux service utility can be run on either
Xnode to report the current state of the replication, background processes, and
Xthe controller itself.
X
X	service appdcontroller status
X
XWatchdog:
X---------
XIf enabled, this background process running on the secondary will monitor the
Xprimary controller and database, and if it detects a failure, will initiate a
Xfailover automatically.   The failure mode timings are defined in watchdog.sh.
XThe watchdog is only enabled if the file <controller root>/HA/WATCHDOG_ENABLE
Xexists. Removing the file causes the watchdog to exit.
X
Xto enable the watchdog, as root:
X	touch <controller root>/HA/WATCHDOG_ENABLE
X	chmod 777 <controller root>/HA/WATCHDOG_ENABLE
X	service appdcontroller start
X
Xrunning the replicate.sh script with the -w option at final activation will 
Xcreate the watchdog control file automatically.
X
XAssassin:
X---------
XAfter a failover, it is possible that the old primary may come online.  If this
Xoccurs, the load balancer may send load to the old primary.  To prevent this,
Xthe new primary continually polls the old primary and if it becomes accessible,
Xkills it and inhibits it from starting again.
X
XFailover:
X---------
XA manual failover can be triggered by running failover.sh on the secondary.
XThis will kill the watchdog and activate the database.  it will also try to
Xassassinate the old primary.
XThis only happens if replication is broken. if replication is good, we just
Xdeactivate the other appserver and activation this one, while leaving the db
Xup.  this case also does not fire up the assassin.
X
XLogging:
X--------
Xthe logs directory contains several status and progress logs of the various components.
X
XBest Practices:
X---------------
XIf possible, a dedicated network connection should be provisioned between the
XHA pair.  this set of interfaces should be the ones placed into the /etc/hosts
Xfiles, and used as the argument for the -s option to the replicate.sh script.
X
XBackups are best done by stopping the appdcontroller service on the secondary
Xand performing a file-level copy of the appdynamics directories.  these can
Xbe incremental or complete, depending on the reliability of your solution.
Xwhen the backup is done, simply start the service; replication will catch up
Xand guarantee the integrity of your data.
X
XA load balancer can probe http://<controller>:<port>/rest/serverstatus
Xto determine which of the two controllers is active. the active node will
Xreturn a HTTP 200.
X
Xshould it be necessary to have a hook in the failover process, for example to update 
Xa dynamics DNS service or to notify a load balancer or proxy, the failover.sh script 
Xis the place to add code.
X
XVersion:
X--------
X$Id: README 1.9 2015-12-23 00:36:28 cmayer Exp $
X
END-of-README
echo x - Makefile
sed 's/^X//' >Makefile << 'END-of-Makefile'
X#
X# makefile for HA script distro
X# $Id: Makefile 2.7 2015-12-23 00:36:28 cmayer $
X#
XAPPD_ROOT=/opt/AppDynamics/Controller
X
XSOURCES= README Makefile \
X	appdcontroller-db.sh appdcontroller.sh \
X	assassin.sh failover.sh watchdog.sh \
X	install-init.sh uninstall-init.sh \
X	watchdog.settings.template \
X	replicate.sh install-init.sh uninstall-init.sh \
X	appdservice.c appdservice-pbrun.sh appdservice-root.sh hafunctions.sh RUNBOOK
X
Xall: HA.shar
X
Xsource: $(SOURCES)
X
Xinstall:
X	rm -f $(APPD_ROOT)/HA/*
X	mkdir -p $(APPD_ROOT)/HA
X	cp README *.sh $(APPD_ROOT)/HA
X	sudo $(APPD_ROOT)/HA/install-init.sh
X
XHA.shar: $(SOURCES) Makefile
X	date +"# HA package built %c" > HA.shar
X	echo "if echo '" >> HA.shar
X	echo "' | od -b | grep -q 015 ; then echo dos format script - exiting ; exit 0 ; fi ; true" >> HA.shar
X	shar $(SOURCES) | sed -e 's/^exit/chmod ugo+rx . .. *.sh; exit/' >> HA.shar
X
X#
X# not used normally, as the install-init.sh compiles it in an installation
X# here for development purposes.
X#
Xappdservice: appdservice.c
X	cc -DAPPDUSER=`id -u` -o appdservice appdservice.c
END-of-Makefile
echo x - appdcontroller-db.sh
sed 's/^X//' >appdcontroller-db.sh << 'END-of-appdcontroller-db.sh'
X#!/bin/bash
X### BEGIN INIT INFO
X# Provides:          appdcontroller-db
X# Required-Start:    $remote_fs $syslog
X# Required-Stop:     $remote_fs $syslog
X# Should-Start:      zfs
X# Should-Stop:       zfs
X# Default-Start:     2 3 4 5
X# Default-Stop:      0 1 6
X# Short-Description: AppDynamics Controller
X# Description:       This script starts and stops the AppDynamics Controller
X#                    Database, appserver, and HA components.
X### END INIT INFO
X#
X# $Id: appdcontroller-db.sh 1.9 2015-08-24 14:37:53 cmayer $
X# 
X# HA Aware Init file for AppDynamics Controller 
X# 
X# chkconfig: 2345 60 25 
X# description: Controller for AppDynamics
X#
X# assumes that the appdynamics controller and database run as the user 
X# specified in the db.cnf file
X#
X# edit this manually if it hasn't been automatically set by the install-init.sh
X# script
X#
XNAME=$(basename $(readlink -e $0))
X
XAPPD_ROOT=/opt/AppDynamics/Controller
XDOMAIN_XML=$APPD_ROOT/appserver/glassfish/domains/domain1/config/domain.xml
XEVENTS_SERVICE_VMOPTIONS_FILE=$APPD_ROOT/events_service/analytics-processor/conf/analytics-processor.vmoptions
XRUNUSER=root
X
Xif [ `id -un` == $RUNUSER ] ; then
X        function runuser {
X                $*
X        }
Xelse
X        function runuser {
X                su -s /bin/bash -c "$*" $RUNUSER
X        }
Xfi
X
Xif runuser [ ! -f $APPD_ROOT/db/db.cnf ] ; then
X	echo appd controller not installed in $APPD_ROOT
X	exit 1
Xfi
X
XDB_CNF=/tmp/db.cnf.$$
Xfunction cleanup() {
X	rm -f $DB_CNF
X}
Xtrap cleanup EXIT
X
Xcleanup
Xrunuser cat $APPD_ROOT/db/db.cnf > $DB_CNF
X
XOPEN_FD_LIMIT=`awk -F= '/^[\t ]*open_files_limit=/{print $2; exit}' $DB_CNF`
Xif [ "$OPEN_FD_LIMIT" -lt 65536 ]; then
X	OPEN_FD_LIMIT=65536
Xfi
X
X#
X# Create (touch) a file called LARGE_PAGES_ENABLE in $APPD_ROOT/HA
X# to enable explicit huge pages support for mysqld and java.
X#
X# If other programs on this system are also using huge pages,
X# Please add the appdynamics runtime user to the group specified by
X# /proc/sys/vm/hugetlb_shm_group
X#
X# If AppDynamics is the only application on this host using huge pages,
X# /proc/sys/vm/hugetlb_shm_group will be updated automatically.
X# See https://www.kernel.org/doc/Documentation/vm/hugetlbpage.txt
X# for more information.
X#
XENABLE_HUGE_PAGES="false"
XHUGE_PAGE_SIZE_BYTES=`awk '/Hugepagesize:/{print $2*1024}' /proc/meminfo`
X
Xif [ -f $APPD_ROOT/HA/LARGE_PAGES_ENABLE ] ; then
X	ENABLE_HUGE_PAGES="true"
Xfi
X
XAPPD_BIN="$APPD_ROOT/bin"
Xlockfile=/var/lock/subsys/$NAME
X[ -d /var/lock/subsys ] || mkdir /var/lock/subsys
X
Xfunction require_root {
X	if [ `id -un` != "root" ] ; then
X		echo "service changes must be run as root"
X		exit 1
X	fi
X}
X
X#
X# trivial sanity check
X#
Xif runuser [ ! -x $APPD_BIN/controller.sh ] ; then
X	echo controller disabled on this host
X	exit 1
Xfi
X
X
X
Xfunction enable_pam_limits() {
X	if [ -f /etc/pam.d/common-session ] && \
X		! grep  -Eq "^[\t ]*session[\t ]+required[\t ]+pam_limits\.so" /etc/pam.d/common-session ; then
X		echo "session required	pam_limits.so" >> /etc/pam.d/common-session
X	elif [ -f /etc/pam.d/system-auth ] && \
X		! grep  -Eq "^[\t ]*session[\t ]+required[\t ]+pam_limits\.so" /etc/pam.d/system-auth ; then
X		echo "session required	pam_limits.so" >> /etc/pam.d/system-auth
X	fi
X}
X
X# always make sure this gets called before any other functions that modify
X# /etc/security/limits.d/appdynamics.com, i.e. reserve_memory()
Xfunction set_open_fd_limits() {
X	if [ "$RUNUSER" == "root" ] && [[ `ulimit -S -n` -lt $OPEN_FD_LIMIT ]]
X		then
X		ulimit -n $OPEN_FD_LIMIT
X	elif [[ `su -s /bin/bash -c "ulimit -S -n" $RUNUSER` -lt "$OPEN_FD_LIMIT" ]]
X		then
X		echo "$RUNUSER  soft  nofile $OPEN_FD_LIMIT" > /etc/security/limits.d/appdynamics.conf
X		echo "$RUNUSER  hard  nofile $OPEN_FD_LIMIT" >> /etc/security/limits.d/appdynamics.conf
X		enable_pam_limits
X	fi
X}
X
Xfunction db_running() {
X	DB_PID_FILE=`cat $DB_CNF | grep "^[\t ]*pid-file" | cut -d = -f 2`
X	DB_DATA_DIR=`cat $DB_CNF | grep "^[\t ]*datadir" | cut -d = -f 2`
X	if [ -z "$DB_PID_FILE" ] ; then
X		DB_PID_FILE="$DB_DATA_DIR/$(hostname).pid"
X	fi
X	if [ -z "$DB_PID_FILE" ] ; then
X		return 1
X	fi
X	DB_PID=`runuser cat $DB_PID_FILE 2>/dev/null`
X	if [ -z "$DB_PID" ] ; then
X		return 1
X	fi
X	if [ -d /proc/$DB_PID ] ; then
X		return 0;
X	fi
X	return 1	
X}
X
Xfunction replication_disabled() {
X	if cat $DB_CNF | grep -q "^[\t ]*skip-slave-start=true" ; then
X		return 0
X	else
X		return 1
X	fi
X}
X
Xfunction active() {
X	if echo select value from global_configuration_local \
X			where "name='appserver.mode'" | \
X		runuser $APPD_BIN/controller.sh login-db | \
X		tail -1 | grep -q "active" ; then
X		return 0
X	else
X		return 1
X	fi
X}
X
Xfunction host_crash(){
X	local lockfile_age=$(($(date +%s)-$(ls -l --time-style=+%s $lockfile | cut -d \  -f 6)))
X	local uptime=$(printf '%.0f\n' $(cat /proc/uptime | cut -d \  -f 1))
X	[ "$lockfile_age" -gt "$uptime" ]
X}
X
Xfunction calculate_memory(){
X	JVM_OPTIONS=`echo "cat /domain/configs/config[@name='server-config']/java-config/jvm-options" | runuser xmllint --shell $DOMAIN_XML`
X	
X	# multiply by 1.05 and round to account for extra 2% allocation overhead +
X	#  headroom
X	CONTROLLER_HEAP=`echo "$JVM_OPTIONS" | awk '/-Xmx/{
X		gsub(/<\/?jvm-options>(-Xmx)?/,"")
X			if(sub(/[k,K]$/,"")==1){ 
X				BYTES=$0*1024 
X			}
X			else if(sub(/[m,M]$/,"")==1){ 
X				BYTES=$0*1048576 
X			}
X			else if(sub(/[g,G]$/,"")==1){ 
X				BYTES=$0*1073741824 
X			} else { 
X				gsub(/[^0-9]/,"") 
X				BYTES=$0 
X			} 
X		}
X		END{
X			BYTES=BYTES*1.05
X			printf("%.0f\n", BYTES)
X		}'`
X		
X	#Parse controller JVM OPTIONS to get MaxPermSize
X	CONTROLLER_MAXPERMSIZE=`echo "$JVM_OPTIONS" | awk '/-XX:MaxPermSize=/{
X		gsub(/<\/?jvm-options>(-XX:MaxPermSize=)?/,"")
X			if(sub(/[k,K]$/,"")==1){ 
X				BYTES=$0*1024 
X			}
X			else if(sub(/[m,M]$/,"")==1){ 
X				BYTES=$0*1048576 
X			}
X			else if(sub(/[g,G]$/,"")==1){ 
X				BYTES=$0*1073741824 
X			} else { 
X				gsub(/[^0-9]/,"") 
X				BYTES=$0 
X			} 
X		}
X		END{print BYTES}'`
X
X	# multiplying by 1.1 and rounding in awk to account for the extra
X	# memory MySQL allocates arround the InnoDB buffer pool.
X	INNODB_BUFFER_POOL=`cat $DB_CNF | \
X		awk -F= '/^[\t ]*innodb_buffer_pool_size/{ 
X		if(sub(/[K][\t ]*$/,"",$2)==1){
X			BYTES=$2*1024
X		}
X		else if(sub(/[M][\t ]*$/,"",$2)==1){
X			BYTES=$2*1048576
X		}
X		else if(sub(/[G][\t ]*$/,"",$2)==1){
X			BYTES=$2*1073741824 
X		} else {
X			gsub(/[^0-9]/,"",$2) 
X			BYTES=$2
X		}
X		BYTES=BYTES*1.1
X		printf("%.0f\n", BYTES)
X		exit; 
X	}'`
X	
X	INNODB_ADDITIONAL_MEM=`cat $DB_CNF | \
X		awk -F= '/^[\t ]*innodb_additional_mem_pool_size=/{ 
X		if(sub(/[K][\t ]*$/,"",$2)==1){
X			BYTES=$2*1024
X		}
X		else if(sub(/[M][\t ]*$/,"",$2)==1){
X			BYTES=$2*1048576
X		}
X		else if(sub(/[G][\t ]*$/,"",$2)==1){
X			BYTES=$2*1073741824
X		} else {
X			gsub(/[^0-9]/,"",$2)
X			BYTES=$2
X		}
X			print BYTES;
X		exit;
X	}'`
X	
X	# multiply by 1.05 and round to account for extra 2% allocation overhead +
X	#  headroom
X	EVENTS_SERVICE_HEAP=`( runuser cat $APPD_ROOT/bin/controller.sh ) \
X		| awk -F= '/^[\t ]*EVENTS_SERVICE_HEAP_SETTINGS=/{
X			$0=substr($2, match($2,/-Xmx[1-9][0-9]*[k,K,m,M,g,G]?/), RLENGTH)
X			sub(/^-Xmx/,"")
X				if(sub(/[k,K]$/,"")==1){
X					BYTES=$0*1024
X				}
X				else if(sub(/[m,M]$/,"")==1){
X					BYTES=$0*1048576
X				}
X				else if(sub(/[g,G]$/,"")==1){
X					BYTES=$0*1073741824
X				} else {
X					gsub(/[^0-9]/,"")
X					BYTES=$0
X				}
X			}
X		END{
X			BYTES=BYTES*1.05
X			printf("%.0f\n", BYTES)
X		}'`
X	
X	if [ -z "$EVENTS_SERVICE_HEAP" ] ; then
X		EVENTS_SERVICE_HEAP=`( runuser cat $EVENTS_SERVICE_VMOPTIONS_FILE ) \
X			| awk '/^[\t ]*-Xmx[1-9][0-9]*[k,K,m,M,g,G]?/{
X				sub(/^-Xmx/,"")
X					if(sub(/[k,K][\t ]*$/,"")==1){
X						BYTES=$0*1024
X					}
X					else if(sub(/[m,M][\t ]*$/,"")==1){
X						BYTES=$0*1048576
X					}
X					else if(sub(/[g,G][\t ]*$/,"")==1){
X						BYTES=$0*1073741824
X					} else {
X						gsub(/[^0-9]/,"")
X						BYTES=$0
X					}
X				}
X			END{
X				BYTES=BYTES*1.05
X				printf("%.0f\n", BYTES)
X			}'`
X	fi
X
X	if [ -z "$EVENTS_SERVICE_HEAP" ] ; then
X		EVENTS_SERVICE_HEAP=0
X	fi
X		
X	# Parse events service JVM options for MaxPermSize.  Default to 64M if not set
X	EVENTS_SERVICE_MAXPERMSIZE=`( runuser cat $EVENTS_SERVICE_VMOPTIONS_FILE ) \
X		| awk '/^[\t ]*-XX:MaxPermSize=[1-9][0-9]*[k,K,m,M,g,G]?/{
X			sub(/^[\t ]*-XX:MaxPermSize=/,"")
X				if(sub(/[k,K][\t ]*$/,"")==1){
X					BYTES=$0*1024
X				}
X				else if(sub(/[m,M][\t ]*$/,"")==1){
X					BYTES=$0*1048576
X				}
X				else if(sub(/[g,G][\t ]*$/,"")==1){
X					BYTES=$0*1073741824
X				} else {
X					gsub(/[^0-9]/,"")
X					BYTES=$0
X				}
X			}
X		END{
X			BYTES=BYTES*1.05
X			printf("%.0f\n", BYTES)
X		}'`
X		
X	if [ "$EVENTS_SERVICE_MAXPERMSIZE" -lt 1 ] ; then
X		# Java permsize defaults to 64MiB
X		EVENTS_SERVICE_MAXPERMSIZE=67108864
X	fi
X	
X	((APPD_TOTAL_RESERVED_BYTES=\
XCONTROLLER_HEAP+\
XCONTROLLER_MAXPERMSIZE+\
XINNODB_BUFFER_POOL+\
XINNODB_ADDITIONAL_MEM+\
XEVENTS_SERVICE_HEAP+\
XEVENTS_SERVICE_MAXPERMSIZE))
X	
X	((APPD_HUGE_PAGES=APPD_TOTAL_RESERVED_BYTES/HUGE_PAGE_SIZE_BYTES))
X	if [ $((APPD_TOTAL_RESERVED_BYTES%HUGE_PAGE_SIZE_BYTES)) -gt 0 ]
X		then
X		# Round up
X		((APPD_HUGE_PAGES++))
X	fi
X	
X	PAGE_SIZE_BYTES=`getconf PAGE_SIZE`
X}
X
X#
X# Explicitly reserve memory for major contorller components
X#
Xfunction reserve_memory (){
X	#set swappiness to zero
X	echo 0 > /proc/sys/vm/swappiness
X	
X	calculate_memory
X
X	#
X	# If zfs is running on this host
X	# Carve room for controller heap, innodb_buffer_pool_size and
X	# innodb_additional_mem_pool_size.  Leave 20% system RAM uncommitted.
X	#
X
X	TOTAL_RESERVABLE_MEM=`free -b | awk '/Mem:/{RESERVABLE_MEM=$2*0.8; printf("%.0f\n", RESERVABLE_MEM)}'`
X	(( REQ_ZFS_ARC_MAX=TOTAL_RESERVABLE_MEM-APPD_TOTAL_RESERVED_BYTES ))
X	# warn if heap plus innodb_buffer_pool_size is greater than available RAM
X	if [ "$REQ_ZFS_ARC_MAX" -lt "0" ] ; then
X		echo "\
X$NAME: Warning!  Controller Heap + innodb_buffer_pool_size
X+ innodb_additional_mem_pool_size, ($APPD_TOTAL_RESERVED_BYTES bytes), greater
Xthan reservable system RAM, ($TOTAL_RESERVABLE_MEM bytes)."
X	else
X		if zpool list >/dev/null 2>&1 ; then 
X			ZFS_ARC_MAX=`cat /sys/module/zfs/parameters/zfs_arc_max`
X			if ([ "$ZFS_ARC_MAX" -eq "0" ] || [ "$ZFS_ARC_MAX" -gt "$REQ_ZFS_ARC_MAX" ]) ; then
X				echo $REQ_ZFS_ARC_MAX > /sys/module/zfs/parameters/zfs_arc_max
X			fi
X		fi
X	fi
X	
X
X	# If huge pages are supported and enabled.
X	if [ -n "$HUGE_PAGE_SIZE_BYTES" ] && [ "$ENABLE_HUGE_PAGES" == "true" ]
X		then
X		local SHMMAX_MAX
X		local SHMALL_MAX
X		if [[ `uname -m` == "x86_64" ]]
X			then
X			SHMMAX_MAX=`echo "2^64 - 16777217" | bc`
X		else
X			SHMMAX_MAX=`echo "2^32 - 16777217" | bc`
X		fi
X		SHMALL_MAX=$SHMMAX_MAX
X		
X	  	# Explicitly allocate and enable huge pages for the controller's
X		# java and mysql processes
X		
X		echo $(($(cat /proc/sys/vm/nr_hugepages)+APPD_HUGE_PAGES)) > /proc/sys/vm/nr_hugepages
X
X		# Allow the AppDynamics user to access the huge pages we're allocating.
X		if ! id -G $RUNUSER | grep -wq `cat /proc/sys/vm/hugetlb_shm_group`
X			then
X			echo $(id -g $RUNUSER) > /proc/sys/vm/hugetlb_shm_group
X		fi
X		
X		#check/set shmmax
X		#use bc to handle unsigned 64-bit unsigned integers
X		((APPD_SHMMAX=APPD_HUGE_PAGES*HUGE_PAGE_SIZE_BYTES))
X		local PROC_SHMMAX=$(cat /proc/sys/kernel/shmmax)
X		[[ $(echo "$PROC_SHMMAX < $SHMMAX_MAX"|bc) == "1" ]] \
X			&& echo "shmmax = $PROC_SHMMAX+$APPD_SHMMAX; \
X			if (shmmax > $SHMMAX_MAX) shmmax=$SHMMAX_MAX; print shmmax;"\
X				| bc > /proc/sys/kernel/shmmax
X
X		#check/set shmmall
X		#use bc to handle unsigned 64-bit unsigned integers
X		((APPD_SHMALL=APPD_SHMMAX/PAGE_SIZE_BYTES))
X		local PROC_SHMALL=$(cat /proc/sys/kernel/shmall)
X		[[ $(echo "$PROC_SHMALL < $SHMALL_MAX"|bc) == "1" ]] \
X			&& echo "shmall = $PROC_SHMALL+$APPD_SHMALL; \
X			if(shmall > $SHMALL_MAX) shmall=$SHMALL_MAX; print shmall;" \
X				| bc > /proc/sys/kernel/shmall
X	
X		# check/set unlimited memlock limit for $RUNUSER
X		if [[ $RUNUSER == "root" ]]
X			then
X			ulimit -l unlimited
X		else
X			if [[ $(su -s /bin/bash -c "ulimit -l" $RUNUSER) != "unlimited" ]]
X				then
X				echo "$RUNUSER  soft  memlock  unlimited" >> /etc/security/limits.d/appdynamics.conf
X				echo "$RUNUSER  hard  memlock  unlimited" >> /etc/security/limits.d/appdynamics.conf
X			fi
X		fi
X		
X		# check/tweak db.cnf
X		if ! cat $DB_CNF | grep -Eq "^\s*large-pages"
X			then
X			runuser ex -s $APPD_ROOT/db/db.cnf <<- MYSQL_LARGE_PAGES
X				/\[mysqld\]/
X				+
X				i
X				large-pages
X				.
X				wq
X			MYSQL_LARGE_PAGES
X		fi
X		
X		# check/tweak domain.xml
X
X		if ! echo "$JVM_OPTIONS" | grep -q "\-XX:+UseLargePages"
X			then
X			runuser ex -s $DOMAIN_XML <<- JAVA_LARGE_PAGES
X				/<config name="server-config">/
X				/java-config/
X				+
X				i
X				<jvm-options>-XX:+UseLargePages</jvm-options>
X				<jvm-options>-XX:LargePageSizeInBytes=$HUGE_PAGE_SIZE_BYTES</jvm-options>
X				.
X				wq
X			JAVA_LARGE_PAGES
X		elif [[ `echo "$JVM_OPTIONS" \
X			| awk '/-XX:LargePageSizeInBytes/{
X			gsub(/<\/?jvm-options>(-XX:LargePageSizeInBytes=)?/,"");
X				if(sub(/[k,K]$/,"")==1){ 
X					BYTES=$0*1024 
X				}
X				else if(sub(/[m,M]$/,"")==1){ 
X					BYTES=$0*1048576 
X				}
X				else if(sub(/[g,G]$/,"")==1){ 
X					BYTES=$0*1073741824 
X				} else { 
X					gsub(/[^0-9]/,"") 
X					BYTES=$0 
X				} 
X				print BYTES; 
X				exit;
X			}'` != "$HUGE_PAGE_SIZE_BYTES" ]]
X			then
X				runuser ex -s $DOMAIN_XML <<- ADJUST_LARGE_PAGE_SIZE
X					%s/>[\t ]*-XX:LargePageSizeInBytes=.*</>-XX:LargePageSizeInBytes=$HUGE_PAGE_SIZE_BYTES</
X					wq
X				ADJUST_LARGE_PAGE_SIZE
X		fi
X		
X		# check / tweak events service settings
X		if ! ( runuser cat $EVENTS_SERVICE_VMOPTIONS_FILE ) \
X			| grep -q "\-XX:+UseLargePages" ; then
X			runuser ex -s $EVENTS_SERVICE_VMOPTIONS_FILE <<- EVENTS_SERVICE_LARGE_PAGES
X				a
X				-XX:+UseLargePages 
X				-XX:LargePageSizeInBytes=$HUGE_PAGE_SIZE_BYTES
X				.
X				wq
X			EVENTS_SERVICE_LARGE_PAGES
X		# simplify the awk-fu below...
X		elif [[ `( runuser cat $EVENTS_SERVICE_VMOPTIONS_FILE ) \
X			| awk -F= '/^[\t ]*-XX:LargePageSizeInBytes=/{
X				if(sub(/[k,K]$/,"",$2)==1){ 
X					BYTES=$2*1024 
X				}
X				else if(sub(/[m,M]$/,"",$2)==1){ 
X					BYTES=$2*1048576 
X				}
X				else if(sub(/[g,G]$/,"",$2)==1){ 
X					BYTES=$2*1073741824 
X				} else { 
X					gsub(/[^0-9]/,"",$2) 
X					BYTES=$2
X				} 
X				print BYTES; 
X				exit;
X			}'` != "$HUGE_PAGE_SIZE_BYTES" ]] ; then
X			#update large page size
X			runuser ex -s $EVENTS_SERVICE_VMOPTIONS_FILE <<- ADJUST_EVENT_SERVICE_LARGE_PAGE_SIZE
X				%s/-XX:LargePageSizeInBytes=[1-9][0-9]*[k,K,m,M,g,G]\?/-XX:LargePageSizeInBytes=$HUGE_PAGE_SIZE_BYTES/g
X				wq
X			ADJUST_EVENT_SERVICE_LARGE_PAGE_SIZE
X		fi
X	else
X		# disable controller MySQL and Java huge page support, if it was previously enabled
X		# remove "large-pages" from db.cnf
X		if cat $DB_CNF | grep -Eq "^\s*large-pages"
X			then
X			runuser ex -s $APPD_ROOT/db/db.cnf <<- DELETE_MYSQL_LARGE_PAGES
X				/^[\t ]*\[mysqld\][\t ]*$/
X				/^[\t ]*large-pages[\t ]*$/
X				d
X				wq
X			DELETE_MYSQL_LARGE_PAGES
X		fi
X
X		# check/tweak domain.xml
X		if echo "$JVM_OPTIONS" | grep -q "\-XX:+UseLargePages"
X			then
X			runuser ex -s $DOMAIN_XML <<- DELETE_JAVA_LARGE_PAGES
X				%s,[\t ]*<jvm-options>[\t ]*-XX:+UseLargePages[\t ]*</jvm-options>[\t ]*\n*,,g
X				%s,[\t ]*<jvm-options>[\t ]*-XX:LargePageSizeInBytes=.*</jvm-options>[\t ]*\n*,,g
X				wq
X			DELETE_JAVA_LARGE_PAGES
X		fi
X		
X		# remove events service large pages config from controller.sh
X		if ( runuser cat $EVENTS_SERVICE_VMOPTIONS_FILE ) \
X			 | grep -q "^[\t ]*\-XX:+UseLargePages[\t ]*" ; then
X			runuser ex -s $EVENTS_SERVICE_VMOPTIONS_FILE <<- DELETE_EVENTS_SERVICE_LARGE_PAGES
X				%s/^[\t ]*-XX:+UseLargePages[\t ]*\n//g
X				%s/^[\t ]*-XX:LargePageSizeInBytes=.*\n//g
X				wq
X			DELETE_EVENTS_SERVICE_LARGE_PAGES
X		fi
X	fi
X}
X
Xfunction unreserve_memory(){
X	# If huge pages are supported and enabled.
X	if [ -n "$HUGE_PAGE_SIZE_BYTES" ] && [ "$ENABLE_HUGE_PAGES" == "true" ]
X		then
X		calculate_memory
X		local SHMMAX_MAX
X		local SHMALL_MAX
X		if [[ `uname -m` == "x86_64" ]]
X			then
X			SHMMAX_MAX=`echo "2^64 - 16777217" | bc`
X		else
X			SHMMAX_MAX=`echo "2^32 - 16777217" | bc`
X		fi
X		SHMALL_MAX=$SHMMAX_MAX
X		
X	  	# Explicitly allocate and enable huge pages for the controller's
X		# java and mysql processes
X		
X		echo $(($(cat /proc/sys/vm/nr_hugepages)-APPD_HUGE_PAGES)) > /proc/sys/vm/nr_hugepages
X		
X		#check/set shmmax
X		#use bc to handle unsigned 64-bit unsigned integers
X		((APPD_SHMMAX=APPD_HUGE_PAGES*HUGE_PAGE_SIZE_BYTES))
X		local PROC_SHMMAX=$(cat /proc/sys/kernel/shmmax)
X		[[ $(echo "$PROC_SHMMAX < $SHMMAX_MAX"|bc) == "1" ]] \
X			&& echo "shmmax = $PROC_SHMMAX-$APPD_SHMMAX; \
X			if (shmmax > $SHMMAX_MAX) shmmax=$SHMMAX_MAX; print shmmax;"\
X				| bc > /proc/sys/kernel/shmmax
X
X		#check/set shmmall
X		#use bc to handle unsigned 64-bit unsigned integers
X		((APPD_SHMALL=APPD_SHMMAX/PAGE_SIZE_BYTES))
X		local PROC_SHMALL=$(cat /proc/sys/kernel/shmall)
X		[[ $(echo "$PROC_SHMALL < $SHMALL_MAX"|bc) == "1" ]] \
X			&& echo "shmall = $PROC_SHMALL-$APPD_SHMALL; \
X			if(shmall > $SHMALL_MAX) shmall=$SHMALL_MAX; print shmall;" \
X				| bc > /proc/sys/kernel/shmall
X	fi
X}
X
Xcase "$1" in  
Xstart)  
X	require_root
X	# conditionally run reserve_memory
X	# if no lockfile or host crash (stale lockfile precedes last startup): reserve memory
X	# mysql crashed or shut down outside of intit: stale lockfile that is younger than last boot: noop
X	# mysql already running: noop
X	if ! db_running ; then
X		set_open_fd_limits
X		if ! [ -f $lockfile ] || host_crash ; then
X			reserve_memory
X		fi
X		runuser $APPD_BIN/controller.sh start-db
X	fi
X	rm -f $lockfile	
X	touch $lockfile	
X;;  
X  
Xstop)
X	require_root
X	service appdcontroller stop
X	# The default controller shutdown timeout is 45 minutes 
X	# That is a long time to be stuck with a hung appserver on the way down.
X	# Thankfully, we can set an environment variable to override that:
X	export AD_SHUTDOWN_TIMEOUT_IN_MIN=10
X	# call separately because if _stopControllerAppServer () can "exit 1"
X	# which will leave the database still running
X	runuser $APPD_BIN/controller.sh stop-db
X	unreserve_memory
X	rm -f $lockfile
X;;  
X
Xrestart)  
X	$0 stop  
X	$0 start  
X;;  
X  
Xstatus)  
X	if db_running ; then
Xcontrollerversion=`echo "select value from global_configuration_cluster where name='schema.version'" | runuser $APPD_BIN/controller.sh login-db | tail -1`
X	if [ ! -z $controllerversion ] ; then
X		echo version: $controllerversion
X	fi
X		echo -n "db running as $RUNUSER - "
X		if active ; then
X			echo "active"
X		else
X			echo "passive"
X			if replication_disabled ; then
X				echo replication disabled
X			fi
X		fi
X		case `echo "select value from global_configuration_local where name='ha.controller.type'" | runuser $APPD_BIN/controller.sh login-db | tail -1` in
X		primary) 
X			echo primary
X			;;
X		secondary)
X			echo secondary
X			;;
X		notapplicable)
X			echo HA not installed
X			;;
X		*)
X			echo unknown HA type
X			;;
X		esac
X		
X		echo "SHOW SLAVE STATUS\G" | \
X			runuser $APPD_BIN/controller.sh login-db | awk \
X			'/Slave_IO_State/ {print}
X			/Seconds_Behind_Master/ {print} 
X			/Master_Server_Id/ {print}
X			/Master_Host/ {print}'
X	else
X		echo "db not running"
X	fi
X;;
X
X*)  
X        echo "Usage: $0 {start|stop|restart|status}"  
X        exit 1  
Xesac
Xexit 0 
END-of-appdcontroller-db.sh
echo x - appdcontroller.sh
sed 's/^X//' >appdcontroller.sh << 'END-of-appdcontroller.sh'
X#!/bin/bash
X### BEGIN INIT INFO
X# Provides:          appdcontroller
X# Required-Start:    $remote_fs $syslog appdcontroller-db
X# Required-Stop:     $remote_fs $syslog appdcontroller-db
X# Default-Start:     2 3 4 5
X# Default-Stop:      0 1 6
X# Short-Description: AppDynamics Controller
X# Description:       This script starts and stops the AppDynamics Controller
X#                    Database, appserver, and HA components.
X### END INIT INFO
X#
X# $Id: appdcontroller.sh 2.14 2015-09-03 20:50:49 cmayer $
X# 
X# HA Aware Init file for AppDynamics Controller 
X# 
X# chkconfig: 2345 60 25 
X# description: Controller for AppDynamics
X#
X# assumes that the appdynamics controller and database run as the user 
X# specified in the db.cnf file
X#
X# edit this manually if it hasn't been automatically set by the install-init.sh
X# script
X#
X
XNAME=$(basename $(readlink -e $0))
X
X
XAPPD_ROOT=/opt/AppDynamics/Controller
XDOMAIN_XML=$APPD_ROOT/appserver/glassfish/domains/domain1/config/domain.xml
XRUNUSER=root
X
XOPEN_FD_LIMIT=65536
X
XAPPD_BIN="$APPD_ROOT/bin"
Xlockfile=/var/lock/subsys/$NAME
XWATCHDOG=$APPD_ROOT/HA/appd_watchdog.pid
XASSASSIN=$APPD_ROOT/HA/appd_assassin.pid
XWATCHDOG_ENABLE="$APPD_ROOT/HA/WATCHDOG_ENABLE"
XWATCHDOG_STATUS=$APPD_ROOT/logs/watchdog.status
XAPPSERVER_DISABLE="$APPD_ROOT/HA/APPSERVER_DISABLE"
X
Xif [ -f $APPD_ROOT/HA/LARGE_PAGES_ENABLE ] ; then
X	ENABLE_HUGE_PAGES="true"
Xfi
X
Xfunction require_root {
X	if [ `id -un` != "root" ] ; then
X		echo "service changes must be run as root"
X		exit 1
X	fi
X}
X
Xif [ `id -un` == $RUNUSER ] ; then
X        function bg_runuser {
X                exec nohup $* >/dev/null 2>&1 &
X        }
X        function runuser {
X                $*
X        }
Xelse
X        function bg_runuser {
X                su -s /bin/bash -c "exec nohup $* >/dev/null 2>&1 &" $RUNUSER
X        }
X        function runuser {
X                su -s /bin/bash -c "$*" $RUNUSER
X        }
Xfi
X
X#
X# trivial sanity check
X#
Xif runuser [ ! -f $APPD_ROOT/db/db.cnf ] ; then
X	echo appd controller not installed in $APPD_ROOT
X	exit 1
Xfi
Xif runuser [ ! -x $APPD_BIN/controller.sh ] ; then
X	echo controller disabled on this host
X	exit 1
Xfi
X
Xfunction enable_pam_limits() {
X	if [ -f /etc/pam.d/common-session ] && ! grep  -Eq "^\s*session\s+required\s+pam_limits\.so" /etc/pam.d/common-session
X		then
X		echo "session required	pam_limits.so" >> /etc/pam.d/common-session
X	elif [ -f /etc/pam.d/system-auth ] && ! grep  -Eq "^\s*session\s+required\s+pam_limits\.so" /etc/pam.d/system-auth
X		then
X		echo "session required	pam_limits.so" >> /etc/pam.d/system-auth
X	fi
X}
X
X# always make sure this gets called before any other functions that modify
X# /etc/security/limits.d/appdynamics.com, i.e. set_unlimited_memlock()
Xfunction set_open_fd_limits() {
X	if [ "$RUNUSER" == "root" ] && [[ `ulimit -S -n` -lt $OPEN_FD_LIMIT ]]
X		then
X		ulimit -n $OPEN_FD_LIMIT
X	elif [[ `su -s /bin/bash -c "ulimit -S -n" $RUNUSER` -lt "$OPEN_FD_LIMIT" ]]
X		then
X		echo "$RUNUSER  soft  nofile $OPEN_FD_LIMIT" > /etc/security/limits.d/appdynamics.conf
X		echo "$RUNUSER  hard  nofile $OPEN_FD_LIMIT" >> /etc/security/limits.d/appdynamics.conf
X		enable_pam_limits
X	fi
X}
X
Xset_unlimited_memlock() {
X	if [ "$ENABLE_HUGE_PAGES" == "true" ] ; then
X		if [[ $RUNUSER == "root" ]]
X			then
X			ulimit -l unlimited
X		else
X			if [[ $(su -s /bin/bash -c "ulimit -l" $RUNUSER) != "unlimited" ]]
X				then
X				echo "$RUNUSER  soft  memlock  unlimited" >> /etc/security/limits.d/appdynamics.conf
X				echo "$RUNUSER  hard  memlock  unlimited" >> /etc/security/limits.d/appdynamics.conf
X				enable_pam_limits
X			fi
X		fi
X	fi
X}
X
Xfunction watchdog_running() {
X	if runuser [ -f "$WATCHDOG" ] ; then
X		WATCHPID=`runuser cat $WATCHDOG`
X		if [ ! -z "$WATCHPID" ] ; then
X			if [ -d /proc/$WATCHPID ] ; then
X				return 0
X			fi
X		fi
X	fi
X	return 1
X}
X
XDB_CNF=/tmp/db.cnf.$$
Xfunction cleanup() {
X    rm -f $DB_CNF
X}
Xtrap cleanup EXIT
X
Xcleanup
Xrunuser cat $APPD_ROOT/db/db.cnf > $DB_CNF
X
Xfunction assassin_running() {
X	if runuser [ -f "$ASSASSIN" ] ; then
X		ASSASSINPID=`runuser cat $ASSASSIN`
X		if [ ! -z "$ASSASSINPID" ] ; then
X			if [ -d /proc/$ASSASSINPID ] ; then
X				return 0
X			fi
X		fi
X	fi
X	return 1
X}
X
Xfunction db_running() {
X	DB_PID_FILE=`cat $DB_CNF | grep "^\s*pid-file" | cut -d = -f 2`
X	DB_DATA_DIR=`cat $DB_CNF | grep "^\s*datadir" | cut -d = -f 2`
X	if [ -z "$DB_PID_FILE" ] ; then
X		DB_PID_FILE="$DB_DATA_DIR/$(hostname).pid"
X	fi
X	if [ -z "$DB_PID_FILE" ] ; then
X		return 1
X	fi
X	DB_PID=`runuser cat $DB_PID_FILE 2>/dev/null`
X	if [ -z "$DB_PID" ] ; then
X		return 1
X	fi
X	if [ -d /proc/$DB_PID ] ; then
X		return 0;
X	fi
X	return 1	
X}
X
Xfunction replication_disabled() {
X	if cat $DB_CNF | grep -q "^\s*skip-slave-start=true" ; then
X		return 0
X	else
X		return 1
X	fi
X}
X
Xfunction active() {
X	if echo select value from global_configuration_local \
X			where "name='appserver.mode'" | \
X		runuser $APPD_BIN/controller.sh login-db | \
X		tail -1 | grep -q "active" ; then
X		return 0
X	else
X		return 1
X	fi
X}
X
Xfunction controllerrunning () {
X	if pgrep -f -u $RUNUSER "$APPD_ROOT/jre/bin/java -jar ./../modules/admin-cli.jar" >/dev/null ; then
X		return 1	
X	fi
X	if runuser $APPD_ROOT/appserver/glassfish/bin/asadmin list-domains | \
X		grep -q "domain1 running" ; then
X		return 0
X	else
X		return 2
X	fi
X}
X
Xfunction events_running () {
X	if ps -f -u $RUNUSER | grep "$APPD_ROOT/jre/bin/java" | grep "$APPD_ROOT/events_service" >/dev/null ; then
X		return 0
X	fi
X	return 1
X}
X
Xfunction reporting_running () {
X	if pgrep -f -u $RUNUSER "$APPD_ROOT/reporting_service/nodejs/bin/node" >/dev/null ; then
X		return 0
X	fi
X	return 1
X}
X
Xcase "$1" in  
Xstart)  
X	require_root
X	if runuser [ -f $APPSERVER_DISABLE ] ; then
X		echo appdcontroller disabled - incomplete replica:w
X		exit 1
X	fi
X	service appdcontroller-db start
X	set_open_fd_limits
X	set_unlimited_memlock
X	if [[ `id -u $RUNUSER` != "0" ]] && \
X		[[ `echo "cat //*[@port<1024]" | runuser xmllint --shell $DOMAIN_XML | wc -l` -gt 1 ]] ; then
X		#trying to bind java to a privilged port as an unpriviliged user
X		setcap cap_net_bind_service=+ep $APPD_ROOT/jre/bin/java
X		echo "$APPD_ROOT/jre/lib/$(uname -m | sed -e 's/x86_64/amd64/')/jli" > \
X			/etc/ld.so.conf.d/appdynamics.conf
X		ldconfig            
X	fi
X	if active ; then
X		bg_runuser $APPD_BIN/controller.sh start-appserver
X		if replication_disabled ; then
X			if assassin_running ; then
X				echo assassin already running
X			else
X				echo starting assassin 
X				bg_runuser $APPD_ROOT/HA/assassin.sh
X			fi
X		fi
X		if runuser [ -d $APPD_ROOT/events_service ] ; then
X			bg_runuser $APPD_BIN/controller.sh start-events-service
X		fi
X		if runuser [ -d $APPD_ROOT/reporting_service ] ; then
X			bg_runuser $APPD_BIN/controller.sh start-reporting-service
X		fi
X	else
X		if replication_disabled ; then
X			echo passive node - appd replication disabled
X			exit 1
X		fi
X		echo skipping appserver start - HA passive
X		if runuser [ -f $WATCHDOG_ENABLE ] ; then
X			if watchdog_running ; then
X				echo appd watchdog already running 
X			else
X				echo starting appd watchdog
X				bg_runuser $APPD_ROOT/HA/watchdog.sh
X			fi
X		else
X			echo watchdog disabled
X		fi
X	fi
X	rm -f $lockfile	
X	touch $lockfile	
X;;  
X  
Xstop)
X	require_root	
X	if watchdog_running ; then
X		kill -9 $WATCHPID && ( echo appd watchdog killed; \
X		runuser "echo `date` appd watchdog killed >> $APPD_ROOT/logs/watchdog.log" )
X	fi
X	runuser rm -f $WATCHDOG
X	if assassin_running ; then
X		kill -9 $ASSASSINPID && ( echo appd assassin killed; \
X		runuser "echo `date` appd assassin killed >> $APPD_ROOT/logs/assassin.log" )		
X	fi
X	runuser rm -f $ASSASSIN
X	if runuser [ -d $APPD_ROOT/events_service ] ; then
X		runuser $APPD_BIN/controller.sh stop-events-service
X	fi
X	if runuser [ -d $APPD_ROOT/reporting_service ] ; then
X		runuser $APPD_BIN/controller.sh stop-reporting-service
X	fi
X	# The default controller shutdown timeout is 45 minutes 
X	# That is a long time to be stuck with a hung appserver on the way down.
X	# Thankfully, we can set an environment variable to override that:
X	export AD_SHUTDOWN_TIMEOUT_IN_MIN=10
X    runuser $APPD_BIN/controller.sh stop-appserver
X	controllerrunning
X	if [ $? -lt 2 ] ; then
X		echo "forcibly killing appserver"
X		pkill -9 -f "$APPD_ROOT/jre/bin/java -cp $APPD_ROOT/lib/tools.jar"
X		echo "truncate ejb__timer__tbl;" | runuser $APPD_BIN/controller.sh login-db
X	fi
X
X	if [ -e $APPD_ROOT/logs/server.log.lck ] ; then
X		runuser rm -f $APPD_ROOT/logs/server.log.lck
X	fi
X	rm -f $lockfile
X;;  
X
Xrestart)  
X	$0 stop  
X	$0 start  
X;;  
X  
Xstatus)  
X	retcode=0
X	service appdcontroller-db status
X	if watchdog_running ; then
X		echo watchdog running
X		if [ -f $WATCHDOG_STATUS ] ; then
X			cat $WATCHDOG_STATUS
X		fi
X	else
X		echo watchdog not running
X	fi
X	if assassin_running ; then
X		echo assassin running
X	else
X		echo assassin not running
X	fi
X	controllerrunning
X	case $? in
X	0)
X		echo "controller running"
X		;;
X	1)
X		echo "controller started - not up"
X		retcode=1
X		;;
X	*)
X		echo "controller not running"
X		retcode=1
X		;;
X	esac
X	events_running
X	case $? in
X	0)
X		echo "events service running"
X		;;
X	*)
X		echo "events service not running"
X		;;
X	esac
X	reporting_running
X	case $? in
X	0)
X		echo "reporting service running"
X		;;
X	*)
X		echo "reporting service not running"
X		;;
X	esac
X	exit $retcode
X;;
X
X*)  
X        echo "Usage: $0 {start|stop|restart|status}"  
X        exit 1  
Xesac
Xexit 0 
END-of-appdcontroller.sh
echo x - assassin.sh
sed 's/^X//' >assassin.sh << 'END-of-assassin.sh'
X#!/bin/bash
X#
X# $Id: assassin.sh 2.8 2016-01-25 19:32:37 cmayer $
X#
X# assassin.sh
X# run on the active node after a failover, 
X# this shoots down any secondary controller to prevent two actives 
X# from showing up at the load balancer - we won't have any data integrity \
X# problems, since replication is off
X# 
X
X# comment out to print logging messages to STDOUT
Xsilence=">/dev/null"
X
X#
X# this may need editing to conform with your controller install
X#
Xdbuser=root
XAPPD_ROOT=$( cd $(dirname "$0"); cd .. ; pwd)
Xdbpasswd=`cat $APPD_ROOT/db/.rootpw`
Xdbport=`grep ^DB_PORT $APPD_ROOT/bin/controller.sh | cut -d = -f 2`
X
X#
X# these are derived, but should not need editing
X#
XMYSQL="$APPD_ROOT/db/bin/mysql"
XDBCNF="$APPD_ROOT/db/db.cnf"
XCONNECT="--protocol=TCP --user=$dbuser --password=$dbpasswd --port=$dbport"
XASSASSIN=$APPD_ROOT/HA/appd_assassin.pid
X
X#
X# hack to supppress password
X#
XPWBLOCK='sed -e s/\(--password=\)[^-]*/\1=XXX/'
X
Xas_log=$APPD_ROOT/logs/assassin.log
X
Xif [ -f /sbin/service ] ; then
X    service_bin=/sbin/service
Xelif [ -f /usr/sbin/service ] ; then
X    service_bin=/usr/sbin/service
Xelse
X    echo service not found in /sbin or /usr/sbin - exiting
X    exit 1
Xfi
X
X# execute remote service operation
X# args:  flags machine service verb
Xfunction remservice {
X	if [ `id -u` == 0 ] ; then
X		ssh $1 $2 $service_bin $3 $4
X	else
X		if ssh $2 [ -x /sbin/appdservice ] ; then
X			ssh $1 $2 /sbin/appdservice $3 $4
X		else
X			ssh $1 $2 sudo -n $service_bin $3 $4
X		fi
X	fi
X}
X
Xfunction sql {
X	echo "$2 | $MYSQL --host=$1 $CONNECT controller" | $PWBLOCK >> $as_log
X	echo "$2" | $MYSQL --host=$1 $CONNECT controller 2>> $as_log | tee -a $as_log
X}
X
Xecho "  -- assassin log" `date` >> $as_log
X
X#
X# we do a boatload of sanity checks, and if anything is unexpected, we
X# exit with a non-zero status and complain.
X#
Xif [ ! -d "$APPD_ROOT" ] ; then
X	echo controller root $APPD_ROOT is not a directory | tee -a $as_log $silence
X	exit 1
Xfi
Xif [ ! -w "$APPD_ROOT/db/db.cnf" ] ; then
X	echo db configuration $APPD_ROOT/db is not a directory | tee -a $as_log $silence
X	exit 1
Xfi
Xif [ ! -x "$MYSQL" ] ; then
X	echo controller root $MYSQL is not executable | tee -a $as_log $silence
X	exit 1
Xfi
X
X#
X# we must be the active node
X#
Xmode=`sql localhost \
X "select * from global_configuration_local where name = 'appserver.mode'\G" |
X awk '/value:/ { print $2}'`
Xif [ "$mode" == "passive" ] ; then
X	echo "this script must be run on the active node" | tee -a $as_log $silence
X	exit 1
Xfi
X
X#
X# if we are the 'marked primary', the assassin is not needed any more
X#
Xtype=`sql localhost \
X "select * from global_configuration_local where name = 'ha.controller.type'\G" |
X awk '/value:/ { print $2}'`
Xif [ "$type" == "primary" ] ; then
X	echo "assassin unneeded" | tee -a $as_log $silence
X	exit 1
Xfi
X
X#
X# replication must be not be enabled.  there are several markers for this:  
X# skip-slave start is set in out db.cnf
X# the slave is not running
Xif ! grep -q "^skip-slave-start=true" $DBCNF ; then
X	echo slave not disabled | tee -a $as_log $silence
X	exit 1
Xfi
Xprimary=unset
Xeval `sql localhost "show slave status\G" | awk '
X	BEGIN { OFS="" }
X    /Slave_IO_Running:/ {print "slave_io=",$2}
X    /Slave_SQL_Running:/ {print "slave_sql=",$2}
X    /Master_Host:/ {print "primary=",$2}
X'`
Xif [ "$slave_sql" != "No" ] ; then
X	echo slave SQL running | tee -a $as_log $silence
X	exit 1
Xfi
Xif [ "$slave_io" != "No" ] ; then
X	echo slave IO running | tee -a $as_log $silence
X	exit 1
Xfi
Xif [ "$primary" == "unset" ] ; then
X	echo "replication not set up - primary unset" | tee -a $as_log $silence
X	exit 1
Xfi
X	
X#
X# ok, now we know that we are a failed-over primary, and there may be an
X# old primary that may re-appear.  if it does, shoot it, and kick it hard 
X# so it stays down.
X#
X
Xecho "assassin committed" | tee -a $as_log $silence
X
Xecho $$ >$ASSASSIN
X
Xloops=0
Xwhile true ; do
X	if [ $loops -gt 0 ] ; then
X		sleep 60;
X	fi
X	(( loops ++ ))
X
X	echo "  -- killing appserver unconditionally on $primary" >> $as_log
X	remservice -tq $primary appdcontroller stop >> $as_log 2>&1
X
X	#
X	# if the database becomes primary, we don't need to run anymore.
X	#
X	type=`sql localhost \
X		 "select * from global_configuration_local where name = 'ha.controller.type'\G" | awk '/value:/ { print $2}'`
X	if [ "$type" == "primary" ] ; then
X		echo "assassin disabled" | tee -a $as_log $silence
X		exit 1
X	fi
X
X	# if we can't get through, no point doing real work
X	if ! ssh $primary date >/dev/null 2>&1 ; then
X		continue;
X	fi
X
X	# make sure skip-slave-start is in db.cnf
X	cat <<- 'DISABLE' | ssh $primary ex -s $DBCNF >/dev/null 2>&1
X		g/^skip-slave-start/d
X		$a
X		skip-slave-start=true
X		.
X		wq
X	DISABLE
X	if ! ssh $primary grep -q skip-slave-start $DBCNF ; then
X		echo "skip-slave-start insert failed" | tee -a $as_log $silence
X		continue;
X	fi
X
X	# update the remote database
X	sql $primary "stop slave;" >/dev/null
X	sql $primary "update global_configuration_local set value='passive' where name = 'appserver.mode';" >/dev/null
X	sql $primary "update global_configuration_local set value='secondary' where name = 'ha.controller.type';" >/dev/null
X
X	# check if this happened
X	if ! sql $primary "select value from global_configuration_local where name = 'appserver.mode';" | grep -q passive ; then
X		echo "set passive failed" | tee -a $as_log $silence
X		continue;
X	fi
X
X	echo "  -- disable slave autostart on $primary" >> $as_log
X	remservice -tq $primary appdcontroller-db stop >> $as_log 2>&1
X
X	sql localhost "update global_configuration_local set value='primary' where name = 'ha.controller.type';"
X	echo "assassin exiting - old primary killed" >> $as_log
X	rm -f $ASSASSIN
X	exit 0
X
Xdone
X
X#
X# script end
X#
X
END-of-assassin.sh
echo x - failover.sh
sed 's/^X//' >failover.sh << 'END-of-failover.sh'
X#!/bin/bash
X#
X# $Id: failover.sh 2.12 2015-12-23 00:36:28 cmayer $
X#
X# failover.sh
X# run on the passive node, activate this HA node.
X# 
X# if run with the -f option, force failover
X#
X# this may need editing to conform with your controller install
X#
Xdbuser=root
XAPPD_ROOT=$( cd $(dirname "$0"); cd .. ; pwd)
Xdbpasswd=`cat $APPD_ROOT/db/.rootpw`
Xdbport=`grep ^DB_PORT $APPD_ROOT/bin/controller.sh | cut -d = -f 2`
XWATCHDOG=$APPD_ROOT/HA/appd_watchdog.pid
X
X#
X# these are derived, but should not need editing
X#
XMYSQL="$APPD_ROOT/db/bin/mysql"
XDBCNF="$APPD_ROOT/db/db.cnf"
XCONNECT="--protocol=TCP --user=$dbuser --password=$dbpasswd --port=$dbport"
X#
X# hack to supppress password
X#
XPWBLOCK='sed -e s/\(--password=\)[^-]*/\1=XXX/'
X
Xif [ -f /sbin/service ] ; then
X    service_bin=/sbin/service
Xelif [ -f /usr/sbin/service ] ; then
X    service_bin=/usr/sbin/service
Xelse
X    echo service not found in /sbin or /usr/sbin - exiting
X    exit 13
Xfi
X
Xfo_log=$APPD_ROOT/logs/failover.log
X
X#
X# worker function for sql timer
X#
Xfunction sqltimeout {
X        if [ $sqlpid -ne 0 ] ; then
X                echo "killing sql pid $sqlpid"
X                disown $sqlpid
X                kill -9 $sqlpid
X                sqlpid=0
X                sqlkiller=0
X        fi
X}
X
X#
X# args:  hostname command [ timeout ]
X# sql wrapper - knows about timeout - returns 0 on success, nonzero otherwise
X#
Xfunction sql {
X		echo sql $1 "$2" $3 >> $fo_log
X        if [ $# -lt 3 ] ; then
X                echo "$2" | $MYSQL --host=$1 $CONNECT controller
X        else
X                trap sqltimeout SIGALRM
X                tmpfile=/tmp/failover.sql.$$
X                rm -f $tmpfile
X                DELFILES=$tmpfile
X                mypid=$$
X                (sleep $3 ; kill -SIGALRM $mypid) &
X                sqlkiller=$!
X                disown $sqlkiller
X                echo "$2" | $MYSQL --host=$1 $CONNECT controller > $tmpfile &
X                sqlpid=$!
X                wait $sqlpid
X                retval=$?
X                if [ $sqlkiller -ne 0 ] ; then
X                        kill -9 $sqlkiller
X                fi
X                cat $tmpfile
X                rm -f $tmpfile
X                DELFILES=
X                return $retval
X        fi
X}
X
Xfunction bounce_slave {
X	sql localhost "stop slave ; start slave ;" >> $fo_log
X}
X
Xfunction slave_status {
X	bounce_slave
X
X	# wait for the slave to settle
X	connect_count=0
X
X	while [ $connect_count -lt 3 ] ; do
X		eval `sql localhost "show slave status\G" | awk '
X			BEGIN { OFS="" }
X			/Slave_IO_Running:/ {print "slave_io=",$2}
X			/Slave_SQL_Running:/ {print "slave_sql=",$2}
X			/Seconds_Behind_Master:/ {print "seconds_behind=",$2}
X			/Master_Host:/ {print "primary=",$2}
X		'`
X		case "$slave_io" in
X		Connecting) 
X			(( connect_count++ ))
X			sleep 10
X			continue;
X			;;
X		Yes) break
X			;;
X		No) break
X			;;
X		esac
X	done
X}
X
X# abstract out the privilege escalation
Xif [[ `id -u` == 0 ]] ; then
X	function service {
X		$service_bin $1 $2
X	}
X
X	function remservice {
X		ssh $1 $2 $service_bin $3 $4
X	}	
Xelse
X	if [ -x /sbin/appdservice ] ; then
X		function service {
X			/sbin/appdservice $1 $2
X		}
X		function remservice {
X			ssh $1 $2 /sbin/appdservice $3 $4
X		}	
X	else
X		function service {
X			sudo $service_bin $1 $2
X		}
X		function remservice {
X			ssh $1 $2 sudo $service_bin $3 $4
X		}	
X	fi
Xfi
X
X#
X# parse arguments
X#
Xforce=false
X
Xwhile getopts f flag; do
X	case $flag in
X	f)
X		force=true
X		;;
X	*)
X		echo "usage: $0 <options>"
X		echo "    [ -f ] force replication break"
X		exit
X		;;
X	esac
Xdone
X
Xecho "  -- failover log" `date` >> $fo_log
X
X#
X# we do a boatload of sanity checks, and if anything is unexpected, we
X# exit with a non-zero status and complain.
X#
Xif [ ! -d "$APPD_ROOT" ] ; then
X	echo controller root $APPD_ROOT is not a directory | tee -a $fo_log
X	exit 1
Xfi
Xif [ ! -w "$APPD_ROOT/db/db.cnf" ] ; then
X	echo db configuration $APPD_ROOT/db is not a directory | tee -a $fo_log
X	exit 1
Xfi
Xif [ ! -x "$MYSQL" ] ; then
X	echo controller root $MYSQL is not executable | tee -a $fo_log
X	exit 1
Xfi
X
X#
X# we must be the passive node
X#
Xecho "  -- Verify passive node" | tee -a $fo_log
Xmode=`sql localhost \
X "select * from global_configuration_local where name = 'appserver.mode'\G" |
X awk '/value:/ { print $2}'`
Xif [ "$mode" == "active" ] ; then
X	echo "this script must be run on the passive node" | tee -a $fo_log
X	exit 1
Xfi
X
X#
X# we must be replicating
X#
Xecho "  -- Verify replication state" | tee -a $fo_log
Xslave=`sql localhost \ "show slave status\G" | wc -l`
Xif [ "$slave" = 0 ] ; then
X	echo "replication is not running" | tee -a $fo_log
X	if [ $force != "true" ] ; then
X		exit 1
X	else
X		echo "  -- Force Failover even with no slave" | tee -a $fo_log
X		primary_up=false
X	fi
Xfi
X
X#
X# replication must be moderately healthy - it's ok if the other server is down
X#
Xslave_status
Xif [ "$slave_sql" != "Yes" ] ; then
X	echo slave SQL not running - replication error | tee -a $fo_log
X	if [ $force != "true" ] ; then
X		exit 1
X	else
X		echo "  -- Force Failover - stopped slave" | tee -a $fo_log
X		primary_up=false
X	fi
Xfi
Xcase "$slave_io" in 
X	"Yes")
X		primary_up=true
X		;;
X	"Connecting")
X		primary_up=false
X		echo "  -- Primary DB not running" | tee -a $fo_log
X		;;
X	*)
X		echo "Unrecognized state for slave IO: $slave_io" | tee -a $fo_log
X		if [ "$force" != true ] ; then
X			exit 1
X		else
X			echo "  -- Force Failover - unknown slave state" | tee -a $fo_log
X			primary_up=false
X		fi
X		;;
Xesac
X
X#####
X#
X# at this point, we are committed to failing over
X#
X
X#
X# kill the local watchdog if it is up
X#
Xkc=0
Xwhile [ -f $WATCHDOG ] ; do
X	if [ $(($kc % 10)) -eq 0 ] ; then
X		kill `cat $WATCHDOG` >/dev/null 2>&1
X		echo "  -- Kill Watchdog" | tee -a $fo_log
X	fi
X	let kc++
X	sleep 1
Xdone
X
X#
X# kill the local appserver if it's running
X#
Xecho "  -- Kill Local Appserver" | tee -a $fo_log
Xservice appdcontroller stop >> $fo_log 2>&1
X
X#
X# persistently break replication if the primary is down, 
X# or we want to force a replication break
X#
Xif [ "$force" == true -o "$primary_up" == false ] ; then
X	echo "  -- Disable local slave autostart" | tee -a $fo_log
X
X	#
X	# disable automatic start of replication slave
X	# edit the db.cnf to remove any redundant entries for skip-slave-start
X	# this is to ensure that replication does not get turned on by a reboot
X	#
X	ex -s $DBCNF <<- 'DISABLE'
Xg/^skip-slave-start/d
X$a
Xskip-slave-start=true
X.
Xwq
XDISABLE
X	#
X	# now stop the replication slave
X	#
X	echo "  -- Stop local slave " | tee -a $fo_log
X	sql localhost "stop slave;"
Xfi
X
X#
X# if the primary is up, mark it passive, and stop the appserver
X# also, if the old primary is not reachable, ha.controller.type will be changed by the assassin when it finally makes contact.
X#
Xif [ "$primary_up" = "true" ] ; then
X	echo "  -- Stop primary appserver" | tee -a $fo_log
X	remservice -tq $primary appdcontroller stop >> $fo_log 2>&1
X	echo "  -- Mark primary passive + secondary" | tee -a $fo_log
X	if sql $primary "update global_configuration_local set value='passive' where name = 'appserver.mode';" 10 &&
Xsql $primary "update global_configuration_local set value='secondary' where name = 'ha.controller.type';" 10 ; then
X		echo "  -- Mark local primary" | tee -a $fo_log
X		sql localhost "update global_configuration_local set value='primary' where name = 'ha.controller.type';"
X	else
X		echo "  -- Primary DB timeout" | tee -a $fo_log
X		break_replication=true
X	fi
X	if [ "$break_replication" == true ] ; then
X		primary_up=false
X		echo "  -- Stop secondary database" | tee -a $fo_log
X		remservice -tq $primary appdcontroller-db stop >> $fo_log 2>&1
X		ssh -tq $primary ex -s $DBCNF <<- 'DISABLEP'
Xg/^skip-slave-start/d
X$a
Xskip-slave-start=true
X.
Xwq
XDISABLEP
X	fi
Xfi
X
X#
X# the primary is now down and maybe passive; 
X# it is now safe to mark our node active and start the appserver
X#
Xecho "  -- Mark local active" | tee -a $fo_log
Xecho "  -- Starting local Controller" | tee -a $fo_log
Xsql localhost "update global_configuration_local set value='active' where name = 'appserver.mode';"
X#
X# this will start the assassin if needed.
Xservice appdcontroller start >> $fo_log 2>&1
X
X#
X# if the other side was ok, then we can start the service in passive mode
X#
Xif [ "$primary_up" = "true" ] ; then
X	echo "  -- start passive secondary" | tee -a $fo_log
X	remservice -nqf $primary appdcontroller start | tee -a $fo_log 2>&1 &
Xfi
X
Xecho "  -- Failover complete" | tee -a $fo_log
X
Xexit 0
X#
X# script end
X#
X
END-of-failover.sh
echo x - watchdog.sh
sed 's/^X//' >watchdog.sh << 'END-of-watchdog.sh'
X#!/bin/bash
X#
X# $Id: watchdog.sh 2.13 2016-01-25 19:22:04 cmayer $
X#
X# watchdog.sh
X# run on the passive node, fail over if we see the primary is very sick
X# if we are not capable of failing over, fall over immediately
X
X#
X# this is needed to set the output of a pipe to the first failing process
X#
Xset -o pipefail
X
X#
X# skip SSL certificate validation when doing health checks, ( useful for 
X# self-signed certificates, and certs issued by internal, corporate CAs )
X# leave empty to require certificate validation against the host's CA cert bundle
X#
X
XCERT_VALIDATION_MODE="-k"
X
XAPPD_ROOT=$( cd $(dirname "$0"); cd .. ; pwd)
XDOMAIN_XML=$APPD_ROOT/appserver/glassfish/domains/domain1/config/domain.xml
X
Xdbpasswd=`cat $APPD_ROOT/db/.rootpw`
Xdbport=`grep ^port= $APPD_ROOT/db/db.cnf | cut -d = -f 2`
X
X# get all of the ports the controller listens on and determine the accompanying
X# protocols
Xdeclare -a APP_PORT
Xdeclare -a APP_PROTO
X
XIFS=$'\n'
X
Xi=0
Xfor n in $( echo "cat /domain/configs/config[@name='server-config']/network-config/network-listeners/network-listener[@name!='admin-listener' and @name!='controller-config-listener']" | \
X	xmllint --shell $DOMAIN_XML | grep \<network-listener ) ; do
X	APP_PORT[$i]=$(echo "$n" | sed -re 's/^.*port="([0-9]+)".*$/\1/')
X	protocol_name=$(echo "$n" | sed -re 's/^.*protocol="([^"]+)".*$/\1/')
X	
X	if echo "cat /domain/configs/config[@name='server-config']/network-config/protocols/protocol[@name='$protocol_name']/attribute::security-enabled" | xmllint --shell $DOMAIN_XML | grep -q 'security-enabled="true"' ; then
X		APP_PROTO[$i]=https
X	else
X		APP_PROTO[$i]=http
X	fi
X	((i++))
Xdone
XIFS=\ 
X
XWATCHDOG=$APPD_ROOT/HA/appd_watchdog.pid
XRUNUSER=`awk -F= '/^[\t ]*user=/ {print $2}' $APPD_ROOT/db/db.cnf`
X
X#
X# these are derived, but should not need editing
X#
XMYSQL="$APPD_ROOT/db/bin/mysql"
XMYSQLADMIN="$APPD_ROOT/db/bin/mysqladmin"
XDBCNF="$APPD_ROOT/db/db.cnf"
XCONNECT="--protocol=TCP --user=root --password=$dbpasswd --port=$dbport"
XWATCHDOG_ENABLE=$APPD_ROOT/HA/WATCHDOG_ENABLE
XWATCHDOG_SETTINGS=$APPD_ROOT/HA/watchdog.settings
XWATCHDOG_STATUS=$APPD_ROOT/logs/watchdog.status
X
X#
X# hack to supppress password
X#
XPWBLOCK='sed -e s/\(--password=\)[^-]*/\1=XXX/'
X
Xfo_log=$APPD_ROOT/logs/failover.log
Xwd_log=$APPD_ROOT/logs/watchdog.log
Xwd_tmp=/tmp/wd_curl.out.$$
X
X# 
X# These are the default timeouts, in seconds, before the watchdog will
X# initiate a failover.  If they are set to low, they can cause unexpected
X# failover events and controller downtime.  The following defaults are very
X# conservative and should be overridden with site-specific settings in
X# $APPD_ROOT/HA/watchdog.settings
X
X# Controller app server not reachable via HTTP(S):  5 Minutes
XDOWNLIMIT=300
X
X# Controller app server shutting down: 5 Minutes
XFALLINGLIMIT=300
X
X# Controller app server starting up: 60 Minutes
XRISINGLIMIT=3600
X
X# The primary database is not responding: 5 Minutes
XDBDOWNLIMIT=300
X
X# The primary database cannot create a table: 2 Minutes
XDBOPLIMIT=300
X
X# The active controller host is not responding to ICMP echo, (ping),
X# requests: 5 Minutes
XPINGLIMIT=300
X
X#
X# the length of time to wait for a sql statememt to run
XDBWAIT=10
X
X#
X# polling frequency
X#
XLOOPTIME=10
X
X#
X# Time to wait for a ping response
X#
XPINGTIME=2
X
X#
X# Time for curl to wait for a complete response from the controller
X#
XCURL_MAXTIME=2
X
X#
X# Time to wait between consecutive requests to create a dummy table on remote
X#
XDB_CREATE_DELAY=10
X
Xlast_db_create=0
X
X#
X# remove the watchdog pid and temporary curl output file when we exit
X#
Xfunction cleanup () {
X	echo `date` "watchdog exit" >> $wd_log
X	rm -f $WATCHDOG $wd_tmp $DELFILES
X}
X
X#
X# worker function for sql timer
X#
Xfunction sqltimeout {
X	if [ $sqlpid -ne 0 ] ; then
X		echo "killing sql pid $sqlpid"
X		disown $sqlpid
X		kill -9 $sqlpid
X		sqlpid=0
X		sqlkiller=0
X	fi
X}
X
X#
X# args:  hostname command [ timeout ]
X# sql wrapper - knows about timeout - returns 0 on success, nonzero otherwise
X#
Xfunction sql {
X	if [ $# -lt 3 ] ; then
X		echo "$2" | $MYSQL --host=$1 $CONNECT controller
X	else
X		trap sqltimeout SIGALRM
X		tmpfile=/tmp/watchdog.sql.$$
X		rm -f $tmpfile
X		DELFILES=$tmpfile
X		mypid=$$
X		(sleep $3 ; kill -SIGALRM $mypid) &
X		sqlkiller=$!
X		disown $sqlkiller
X		echo "$2" | $MYSQL --host=$1 $CONNECT controller > $tmpfile &
X		sqlpid=$!
X		wait $sqlpid
X		retval=$?
X		if [ $sqlkiller -ne 0 ] ; then
X			kill -9 $sqlkiller
X		fi
X		cat $tmpfile
X		rm -f $tmpfile
X		DELFILES=
X		return $retval
X	fi
X}
X
X#
X# we do a boatload of sanity checks, and if anything is unexpected, we
X# exit with a non-zero status and complain.
X#
Xfunction sanity {
X	if [ ! -d "$APPD_ROOT" ] ; then
X		echo $APPD_ROOT is not a directory >> $wd_log
X		return 0
X	fi
X	if [ ! -w "$APPD_ROOT/db/db.cnf" ] ; then
X		echo $APPD_ROOT/db/db.cnf is not a directory >> $wd_log
X		return 0
X	fi
X	if [ ! -x "$MYSQL" ] ; then
X		echo controller root $MYSQL is not executable >> $wd_log
X		return 0
X	fi
X
X	#
X	# the watchdog enable file must exist.
X	#
X	if [ ! -f $WATCHDOG_ENABLE ] ; then
X		echo watchdog disabled
X		return 0
X	fi
X
X	#
X	# we must be the passive node
X	#
X	mode=`sql localhost \
X	 "select * from global_configuration_local where name='appserver.mode'\G" |
X	 awk '/value:/ { print $2}'`
X	if [ "$mode" == "active" ] ; then
X		echo "this script must be run on the passive node" >> $wd_log
X		return 0
X	fi
X
X	#
X	# we must be replicating
X	#
X	slave=`sql localhost \ "show slave status\G" | wc -l`
X	if [ "$slave" = 0 ] ; then
X		echo "replication is not running" >> $wd_log
X		return 0
X	fi
X
X	#
X	# replication must be moderately healthy - it's ok if the primary is down
X	#
X	eval `sql localhost \ "show slave status\G" | awk '
X		BEGIN { OFS="" }
X		/Slave_IO_Running:/ {print "slave_io=",$2}
X		/Slave_SQL_Running:/ {print "slave_sql=",$2}
X		/Seconds_Behind_Master:/ {print "seconds_behind=",$2}
X		/Master_Host:/ {print "primary=",$2}
X	'`
X	if [ "$slave_sql" != "Yes" ] ; then
X		echo slave SQL not running - replication error >> $wd_log
X		return 0
X	fi
X	case "$slave_io" in 
X		"Yes")
X			primary_up=true
X			;;
X		"Connecting")
X			primary_up=false
X			echo "  -- Primary DB not running" >> $wd_log
X			;;
X		*)
X			echo "Unrecognized state for slave IO: $slave_io" >> $wd_log
X			return 0
X			;;
X	esac
X	return 1
X}
X
X#
X# code to do a rest call for status. 
X#
Xfunction serverstatus {
X	local app_proto=$1
X	local app_port=$2
X	STATUS="$app_proto://$primary:$app_port/controller/rest/serverstatus"
X	curl -m $CURL_MAXTIME -fsS $CERT_VALIDATION_MODE $STATUS > $wd_tmp 2>&1
X	curlstat=$?
X	case "$curlstat" in
X	0)
X		echo good
X		;;
X	7)
X		echo "down"
X		echo "curl error 7" >> $wd_log
X		;;
X	22)
X		eval `awk '/(22)/ {printf("http_code=%d\n", $8);}' < $wd_tmp`
X		echo "curl error 22: $http_code" >> $wd_log
X		cat $wd_tmp >> $wd_log
X		case $http_code in
X		503)
X			echo "falling"
X			;;
X		500)
X			echo "rising"
X			;;
X		404)
X			echo "rising"
X			;;
X		*)
X			echo "other"
X			;;
X		esac
X		;;
X	28)
X		echo "down"
X		echo "curl error 28: operation timed out" >> $wd_log
X		;;
X	35)
X		echo "down"
X		echo "curl error 35" >> $wd_log
X		;;
X	52)
X		echo "no data"
X		echo "curl error 52" >> $wd_log
X		;;
X	*)
X		echo "other"
X		echo "curl error $curlstat" >> $wd_log
X		;;
X	esac
X}
X
X#
X# pass the variable, and limit
X#
X# warning: gnarly shell syntax and usage
X#
Xfunction expired () {
X	if [ ${!1} -eq 0 ] ; then
X		eval "$1=`date +%s`"
X	fi
X	now=`date +%s`
X	limit=$((${!1} + $2))
X	left=$(($limit - $now))
X	echo `date` "expired $1 ${!1} $limit $left $2" >> $wd_log
X	echo "   timer $1 start $limit left $left limit $2" > $WATCHDOG_STATUS
X	if [ `date +%s` -gt $((${!1} + $2)) ] ; then
X		return 0
X	else
X		return 1
X	fi
X}
X
X#
X# our exceptional state loop
X# 
X# here is where we test primary health and return when something happens
X# for long enough
Xfunction poll {
X	local i=0
X
X	downtime=0
X	risingtime=0
X	fallingtime=0
X	pingfail=0
X	dbfail=0
X	dbopfail=0
X
X	rm -f $WATCHDOG_STATUS
X
X	while true ; do
X		#
X		# if somebody removed the watchdog file, stop watching
X		#
X		if [ ! -f $WATCHDOG_ENABLE ] ; then
X			echo watchdog newly disabled >> $wd_log
X			return 0
X		fi
X		
X		#
X		# first, ping the primary.  
X		# occasionally, ICMP is disabled, so PING can be disabled
X		#
X		if [ "$PINGLIMIT" = "0" ] ; then
X			pingfail=0
X		else
X			if ping -c 1 -W $PINGTIME -q $primary >/dev/null 2>&1 ; then
X				pingfail=0
X			else
X				if expired pingfail $PINGLIMIT ; then
X					echo `date` pingfail expired >> $wd_log
X					return 2
X				fi
X				# we can't even ping.  Sleep for $((LOOPTIME-PINGTIME)) then try again
X				sleep $((LOOPTIME-PINGTIME))
X				continue
X			fi
X		fi
X
X		#
X		# then, is the database up listening
X		#
X		if $MYSQLADMIN $CONNECT ping >/dev/null 2>&1 ; then
X			dbfail=0
X		else
X			dbopfail=0
X			downtime=0
X			risingtime=0
X			fallingtime=0
X			pingfail=0
X			if expired dbfail $DBDOWNLIMIT ; then
X				echo `date` dbfail expired >> $wd_log
X				return 2
X			fi
X			sleep $LOOPTIME
X			continue
X		fi
X
X		#
X		# then, is the database capable of doing some real work for us
X		# only do this every DB_CREATE_DELAY
X		#
X		if [ $(($last_db_create+$DB_CREATE_DELAY)) -le `date +%s` ] ; then
X			last_db_create=`date +%s`
X			if 
Xsql $primary "drop table if exists watchdog_test_table;" $DBWAIT &&
Xsql $primary "create table watchdog_test_table (i int);" $DBWAIT &&
Xsql $primary "insert into watchdog_test_table values (1);" $DBWAIT &&
Xsql $primary "select count(*) from watchdog_test_table;" $DBWAIT &&
Xsql $primary "drop table watchdog_test_table;" $DBWAIT ; then
X				dbopfail=0
X			else
X				dbfail=0
X				downtime=0
X				risingtime=0
X				fallingtime=0
X				pingfail=0
X				if expired dbopfail $DBOPLIMIT ; then
X					echo `date` dbopfail expired >> $wd_log
X					return 2
X				fi
X				sleep $LOOPTIME
X				continue
X			fi
X		fi
X
X		#
X		# how does the appserver respond to a serverstatus REST?
X		# if down, try every port before calling expired()
X		#
X		status=`serverstatus ${APP_PROTO[$i]} ${APP_PORT[$i]}`
X		case $status in
X		down)
X			if [ $i -lt $((${#APP_PROTO[@]}-1)) ] ; then
X				((i++))
X				continue
X			else
X				i=0
X			fi
X			risingtime=0
X			fallingtime=0
X			pingfail=0
X			dbfail=0
X			dbopfail=0
X			if expired downtime $DOWNLIMIT ; then
X				echo `date` downtime expired >> $wd_log
X				return 2
X			fi
X			;;
X		rising)
X			# reset the other timers
X			downtime=0
X			fallingtime=0
X			pingfail=0
X			dbfail=0
X			dbopfail=0
X
X			if expired risingtime $RISINGLIMIT ; then
X				echo `date` risingtime expired >> $wd_log
X				return 2
X			fi
X			;;
X		falling)
X			downtime=0
X			risingtime=0
X			pingfail=0
X			dbfail=0
X			dbopfail=0
X			if expired fallingtime $FALLINGLIMIT ; then
X				echo `date` fallingtime expired >> $wd_log
X				return 2
X			fi
X			;;
X		good)
X			return 0
X			;;
X		*)
X			echo `date` "unknown status $status" >> $wd_log
X			return 1
X			;;
X		esac
X		
X		sleep $LOOPTIME
X	done
X}
X
X#
X# begin actual code
X#
Xif [ `id -un` != "$RUNUSER" ] ; then
X	echo watchdog must run as $RUNUSER
X	exit 1
Xfi
X
X#
X# only run one watchdog
X#
Xif [ -f "$WATCHDOG" ] ; then
X	WATCHPID=`cat $WATCHDOG`
X	if [ ! -z "$WATCHPID" ] ; then
X		if kill -0 $WATCHPID 2>/dev/null ; then
X			echo watchdog already running
X			exit 1
X		fi
X	fi
Xfi
X
X#
X# we are starting to run. register
X#
Xtrap cleanup EXIT
Xrm -f $WATCHDOG
Xecho $$ > $WATCHDOG
X
X#
X# overrides, so we don't have to edit this file
X#
Xif [ -f $WATCHDOG_SETTINGS ] ; then
X	source $WATCHDOG_SETTINGS
Xfi
X
X#
X# force first report
X#
Xlaststatus=1
X
X#
X# our main loop.  every time the controller is noted up, we start from scratch.
X#
Xwhile true ; do
X	if [ ! -f $wd_log ] ; then
X		echo "  -- watchdog log " `date` > $wd_log
X		echo "  -- settings: down:$DOWNLIMIT falling:$FALLINGLIMIT \
X rising:$RISINGLIMIT dbdown:$DBDOWNLIMIT ping:$PINGLIMIT loop:$LOOPTIME" >> $wd_log
X	fi
X	if sanity ; then
X		if [ -f $WATCHDOG_ENABLE ] ; then
X			echo "failover not possible" | tee -a $wd_log
X		fi
X		echo "watchdog exiting" | tee -a $wd_log
X		exit 1
X	fi
X
X	poll
X	pollstatus=$?
X	case $pollstatus in
X	0)
X		# don't report consecutive good to minimize noise
X		if [ $laststatus != '0' ] ; then
X			date >> $wd_log
X			echo "watchdog good" >> $wd_log
X		fi
X		;;
X	2)
X		date >> $wd_log
X		echo "failover invoked" >> $wd_log
X		$APPD_ROOT/HA/failover.sh >> $fo_log 2>&1 &
X		exit 0
X		;;
X	1|*)
X		date >> $wd_log
X		echo "watchdog abort poll status = $pollstatus" >> $wd_log
X		exit 1
X		;;
X	esac
X	sleep $LOOPTIME
X	laststatus=$pollstatus
Xdone
X
X#
X# script end
X#
END-of-watchdog.sh
echo x - install-init.sh
sed 's/^X//' >install-init.sh << 'END-of-install-init.sh'
X#!/bin/bash
X#
X# $Id: install-init.sh 2.12 2015-12-23 00:36:28 cmayer $
X#
X# install init script
X#
XPBRUN=`grep PBRUN= appdservice-pbrun.sh | awk -F= '{print $2}'`
X
Xfunction usage {
X	echo "$0 -[options] where:"
X	echo "   -c  use setuid c wrapper"
X	echo "   -s  use sudo"
X	echo "   -p  use pbrun wrapper"
X	exit 1
X}
X
Xuse_pbrun=0
Xuse_cwrapper=0
Xuse_sudo=0
Xuse_root=0
X
Xwhile getopts cspr flag; do
X	case $flag in
X	c)
X		use_cwrapper=1
X		;;
X	s)
X		use_sudo=1
X		;;
X	p)
X		if [ -x $PBRUN ] ; then
X			use_pbrun=1
X		else
X			echo $PBRUN not found
X			exit 1
X		fi
X		;;
X	*)
X		usage
X		;;
X	esac
Xdone
X
Xif [ `id -u` != 0 ] ; then
X	echo $0 must be run as root
X	exit 0
Xfi
X
XSCRIPTNAME=$(basename $(readlink -e $0))
X
Xexport PATH=/sbin:/usr/sbin:$PATH
X
X# list of AppDynamics services in start order
XAPPDYNAMICS_SERVICE_LIST=( appdcontroller-db appdcontroller )
X
XVENDOR=`lsb_release -i 2>/dev/null | awk '{print $3}'`
X
Xif echo $VENDOR | grep -iq ubuntu ; then
X	#
X	# Define explicit start and stop order lists for Ubuntu and other distros
X	# were update-rc.d ignores the LSB dependency headers
X	#
X	APPDYNAMICS_SERVICE_START=( 90 91 )
X	APPDYNAMICS_SERVICE_STOP=( 90 89 )
Xfi
X
XAPPDSERVICE=/sbin/appdservice
X
Xcd $(dirname $0)
XAPPD_ROOT=`cd .. ; pwd`
Xif ! [ -d $APPD_ROOT/bin ] ; then
X	APPD_ROOT=/opt/AppDynamics/Controller
X	echo using default path $APPD_ROOT
Xfi
XDOMAIN_XML=$APPD_ROOT/appserver/glassfish/domains/domain1/config/domain.xml
X
XROOTOWNER=`ls -ld $APPD_ROOT | awk '{print $3}'`
XRUNUSER=`su -s /bin/bash -c "awk -F= '/^[\t ]*user=/ {print \\$2}' $APPD_ROOT/db/db.cnf" $ROOTOWNER`
Xif [[ `id -u $RUNUSER` != "0" ]] ; then
X	if [ `expr $use_cwrapper + $use_sudo + $use_pbrun` == 0 ] ; then
X		echo non-root usage requires at least one privilege escalation method
X		usage
X	fi
X	if [ `expr $use_cwrapper + $use_pbrun` == 2 ] ; then
X		echo cwrapper and pbrun are mutually exclusive
X		usage
X	fi
Xelse
X	use_root=1
Xfi
X
XCHKCONFIG=`which chkconfig 2>/dev/null`
XUPDATE_RC_D=`which update-rc.d 2>/dev/null`
XSERVICE=`which service 2>/dev/null`
X
Xfunction require() {
X	# args: executable "redhat package" "debian package" [ force|advise ] ["<reason package is required>"]
X	local errors=0
X	if ! [[  -x `which $1 2>/dev/null` ]] || [ "$4" == "force" ] ; then
X		if [[ -x `which apt-get 2>/dev/null` ]] ; then
X			if [ "$4" == "advise" ] ; then
X				echo "Package $3 not installed."
X				echo "$3 is required $5"
X				return 1
X			else
X				if ! apt-get -qq -y install $3 && [ "$4" == "force" ] ; then
X					errors=1
X				fi
X			fi
X		elif [[ -x `which yum 2>/dev/null` ]] ; then
X			if [ "$4" == "advise" ] ; then
X				echo "Package $2 not installed."
X				echo "$2 is required $5"
X				return 1
X			else
X				if ! yum --quiet -y install $2 >/dev/null && [ "$4" == "force" ] ; then
X					errors=1
X				fi
X			fi
X		fi
X		if ! [[  -x `which $1 2>/dev/null` ]] || [ "$errors" -gt 0 ] ; then
X			echo "Unable to install package containing $1"
X			return 1
X		fi
X	fi
X}
X
Xfunction install_init() {
X	echo "installing /etc/init.d/$1"
X	sed <./$1.sh >/etc/init.d/$1 \
X		-e "/^APPD_ROOT=/s,=.*,=$APPD_ROOT," \
X		-e "/^RUNUSER=/s,=.*,=$RUNUSER,"
X
X	chmod 0744 /etc/init.d/$1
X
X	if [ -x "$CHKCONFIG" ] ; then
X		chkconfig --add $1
X	elif [ -x "$UPDATE_RC_D" ] ; then
X		update-rc.d -f $1 remove 
X		update-rc.d $1 defaults $2 $3
X	else
X		echo "unsupported linux distribution: chkconfig or update-rc.d required"
X		exit 1
X	fi
X}
X
X#
X# make sure we have xmllint, bc, and the right version of ping installed
X#
Xmissing_dependencies=0
Xrequire xmllint libxml2 libxml2-utils || ((missing_dependencies++))
Xrequire bc bc bc || ((missing_dependecies++))
Xrequire ex vim-minimal vim-tiny || ((missing_dependecies++))
Xrequire curl curl curl || ((missing_dependencies++))
Xif ! ping -q -W 1 -c 1 localhost >/dev/null ; then
X	require ping iputils iputils-ping force || ((missing_dependencies++))
Xfi
Xif [ "$missing_dependencies" -gt 0 ] ; then
X	exit 1
Xfi
X
X#
X# since our RUNUSER isn't root, we want to make it so that sudo works
X# for our selected commands.   
X# this is not a security hole, it is a controlled privilege escalation, really.
X#
Xif [[ `id -u $RUNUSER` != "0" ]] ; then
X
X	if [ $use_sudo == 1 ] ; then
X		# Clean up C / pbrun wrappers if they were previously installed
X		rm -f $APPDSERVICE 2>/dev/null
X		require sudo sudo sudo || exit 1
X		[ -d /etc/sudoers.d ] || mkdir /etc/sudoers.d && chmod 0750 /etc/sudoers.d
X		grep -Eq "^#includedir[\t ]+/etc/sudoers.d[\t ]*$" /etc/sudoers || \
X		grep -Eq "^#include[\t ]+/etc/sudoers.d/appdynamics[\t ]*$" /etc/sudoers || \
X		echo "#include /etc/sudoers.d/appdynamics" >> /etc/sudoers
X		if [ -x "$CHKCONFIG" ] ; then
X			COMMA=
X			for s in ${APPDYNAMICS_SERVICE_LIST[@]} ; do
X				CMND_ALIAS_LIST="$CMND_ALIAS_LIST $COMMA \\
X				$SERVICE $s *, \\
X				$CHKCONFIG $s on, \\
X				$CHKCONFIG $s off"
X				COMMA=","
X			done
X		elif [ -x "$UPDATE_RC_D" ] ; then
X			COMMA=
X			for s in ${APPDYNAMICS_SERVICE_LIST[@]} ; do
X				CMND_ALIAS_LIST="$CMND_ALIAS_LIST$COMMA \\
X				$SERVICE $s *, \\
X				$UPDATE_RC_D $s enable, \\
X				$UPDATE_RC_D $s disable"
X				COMMA=","
X			done
X		fi
X		cat > /etc/sudoers.d/appdynamics <<- SUDOERS
X		# allow appdynamics user to:
X		#    start, stop, and query status of appdynamics via init scripts
X		#    to enable and disable those init scripts
X		Defaults:$RUNUSER !requiretty
X		Cmnd_Alias APPD = $CMND_ALIAS_LIST
X			$RUNUSER ALL=(root) NOPASSWD: APPD
X		SUDOERS
X		chmod 0440 /etc/sudoers.d/appdynamics
X		echo "installed /etc/sudoers.d/appdynamics"
X	fi
X
X	if [ $use_cwrapper == 1 ] ; then
X		if require cc gcc gcc advise "to build $APPDSERVICE privilege escalation wrapper" ; then
X			# Clean up sudo privilege escalation if it was previously installed
X			rm -f /etc/sudoers.d/appdynamics 2>/dev/null
X			# compile wrapper, chown and chmod with setuid
X			cc -D_GNU_SOURCE -DAPPDUSER=`id -u $RUNUSER` -o $APPDSERVICE appdservice.c
X			if [ -x $APPDSERVICE ] ; then
X				chown root:root $APPDSERVICE
X				chmod 4755 $APPDSERVICE
X				echo "installed setuid root wrapper as $APPDSERVICE"
X			else
X				echo "installation of $APPDSERVICE failed"
X			fi
X		else
X			echo "Exiting..."
X			exit 1
X		fi
X	fi
X
X	if [ $use_pbrun == 1 ] ; then
X		# Clean up sudo privilege escalation if it was previously installed
X		rm -f /etc/sudoers.d/appdynamics 2>/dev/null
X		# Install the pbrun privilege escalation wrapper
X		cp appdservice-pbrun.sh $APPDSERVICE
X		chmod 755 $APPDSERVICE
X		echo "installed pbrun wrapper as $APPDSERVICE"
X	fi
X
X	if [ $use_root == 1 ] ; then
X		# Clean up sudo privilege escalation if it was previously installed
X		rm -f /etc/sudoers.d/appdynamics 2>/dev/null
X		cp appdservice-root.sh $APPDSERVICE
X		chmod 755 $APPDSERVICE
X		echo "installed root wrapper as $APPDSERVICE"
X	fi
X
X	if ! require setcap libcap libcap2-bin && \
X		[[ `echo "cat //*[@port<1024]" | xmllint --shell $DOMAIN_XML | wc -l` -gt 1 ]] ; then
X		echo "\
XERROR: AppDynamics is configured to bind to at least one port < 1024 as an
Xunprivileged user, but the setcap utility is not available on this host.
XAppDynamics will not run in the configuration."
X		exit 1
X	fi
Xfi
X
X#
X# install all
X#
Xi=0
Xfor s in ${APPDYNAMICS_SERVICE_LIST[@]} ; do
X	install_init $s ${APPDYNAMICS_SERVICE_START[$i]} ${APPDYNAMICS_SERVICE_STOP[$i]}
X	((i++))
Xdone
END-of-install-init.sh
echo x - uninstall-init.sh
sed 's/^X//' >uninstall-init.sh << 'END-of-uninstall-init.sh'
X#!/bin/bash
X#
X# $Id: uninstall-init.sh 1.6 2015-12-23 00:36:28 cmayer $
X#
X# uninstall init script
X#
Xexport PATH=/sbin:/usr/sbin:$PATH
X
Xfunction remove() {
X	if [ ! -f /etc/init.d/$1 ] ; then
X		return
X	fi
X	if [[ -x `which chkconfig 2>/dev/null` ]] ; then
X		chkconfig --del $1
X	elif [[ -x `which update-rc.d 2>/dev/null` ]] ; then
X		update-rc.d -f $1 remove
X	else
X		echo "Failed to remove $1: chkconfig or update-rc.d required"
X		exit 1
X	fi
X	echo removing $1 service
X	rm -f /etc/init.d/$1
X}
X
Xremove appdcontroller
Xremove appdcontroller-db
X
Xif [ -f /sbin/appdservice ] ; then
X	echo removing appdservice wrapper
X	rm -f /sbin/appdservice
Xfi
X
Xif [ -f /etc/sudoers.d/appdynamics ] ; then
X	echo removing appdynamics specific sudoers file
X	rm -f /etc/sudoers.d/appdynamics
X
X	if grep -Eq "^#include[\t ]+/etc/sudoers.d/appdynamics[\t ]*$" /etc/sudoers ; then
X		echo removing sudoers additions
X		ex -s /etc/sudoers <<- RMAPPD
X			g/^#include[\t ][\t ]*\/etc\/sudoers.d\/appdynamics/d
X			wq
X		RMAPPD
X	fi
Xfi
END-of-uninstall-init.sh
echo x - watchdog.settings.template
sed 's/^X//' >watchdog.settings.template << 'END-of-watchdog.settings.template'
X# $Id: watchdog.settings.template 1.5 2015-12-23 00:36:28 cmayer $
X#
X# watchdog.settings
X
X# 
X# These are the default timeouts, in seconds, before the watchdog will
X# initiate a failover.  If they are set to low, they can cause unexpected
X# failover events and controller downtime.  The following defaults are very
X# conservative and should be overridden with site-specific settings by
X# copying this file to $APPD_ROOT/HA/watchdog.settings and editing
X# it appropriately.
X
X# Controller app server not reachable via HTTP(S):  5 Minutes
XDOWNLIMIT=300
X
X# Controller app server shutting down: 5 Minutes
XFALLINGLIMIT=300
X
X# Controller app server starting up: 60 Minutes
XRISINGLIMIT=3600
X
X# The primary database is not responding: 5 Minutes
XDBDOWNLIMIT=300
X
X# The active controller host is not responding to ICMP echo, (ping),
X# requests: 5 Minutes
X# if ICMP is disabled, PING can be disabled by setting PINGLIMIT to 0
XPINGLIMIT=300
X
X# The primary database cannot create a table: 2 Minutes
XDBOPLIMIT=300
X
X#
X# the length of time to wait for a sql statememt to run
XDBWAIT=10
X
X
END-of-watchdog.settings.template
echo x - replicate.sh
sed 's/^X//' >replicate.sh << 'END-of-replicate.sh'
X#!/bin/bash
X#
X# $Id: replicate.sh 2.23 2016-01-25 18:43:03 rob.navarro $
X#
X# install HA to a controller pair
X#
X# this must be run on the primary, and ssh and rsync must be set up 
X# on both machines.
X#
X# if replication isn't broken before you run this, it certainly will be
X# during.
X#
X# this has very limited sanity checking, so please be very careful.
X#
Xprimary=`hostname`
Xinternal_vip=
Xexternal_vip=
Xsecondary=
Xdef_APPD_ROOT=$(cd $(dirname "$0"); cd .. ; pwd)
XAPPD_ROOT=$def_APPD_ROOT
Xdbport=`grep ^port= $APPD_ROOT/db/db.cnf | cut -d = -f 2`
Xdatadir=
Xinnodb_logdir=
Xupgrade=
Xfinal=false
Xrunning_as_root=$( [[ $(id -u) -eq 0 ]] && echo "true" || echo "false" )
X#
X# the services in this list must appear in the order in which they should be
X# stopped
X#
Xappdynamics_service_list=( appdcontroller appdcontroller-db )
X
Xtmpdir=/tmp/ha.$$
X
Xrsync_opts="-PavpW --del --inplace --exclude=ibdata1 --exclude=ib_logfile*"
Xfinal_rsync_opts="-PavpW --del --inplace"
Xrsync_throttle="--bwlimit=20000"
Xstart_appserver=true
Xwatchdog_enable=false
Xrsync_compression=""
Xwildcard=
X
Xif [ -f /sbin/service ] ; then
X	service_bin=/sbin/service
Xelif [ -f /usr/sbin/service ] ; then
X	service_bin=/usr/sbin/service
Xelse 
X    echo service not found in /sbin or /usr/sbin - exiting
X    exit 13
Xfi
X
X# verify that a required executable / package is installed
X# complain and return 1 if not
Xfunction require() {
X	# args: executable "redhat package" "debian package" 
X	if ! [[  -x `which $1 2>/dev/null` ]] ; then
X		echo "Unable to find $1 in $PATH"
X		echo "Please install with:"
X		if [[ -x `which apt-get 2>/dev/null` ]] ; then
X			echo "apt-get update && apt-get install $3"
X		elif [[ -x `which yum 2>/dev/null` ]] ; then
X			echo "yum install $2"
X		fi
X		return 1
X	fi
X	return 0
X}
X
X
X# execute remote service operation
X# args:  flags machine service verb
Xfunction remservice {
X	if [ `id -u` == 0 ] ; then
X		ssh $1 $2 $service_bin $3 $4
X	else
X		if ssh $2 [ -x /sbin/appdservice ] ; then
X			ssh $1 $2 /sbin/appdservice $3 $4
X		else
X			ssh $1 $2 sudo -n $service_bin $3 $4
X		fi
X	fi
X}
X
X# execute service operation
X# args: service verb
Xfunction service {
X	if [ `id -u` == 0 ] ; then
X		$service_bin $1 $2
X	else
X		if [ -x /sbin/appdservice ] ; then
X			/sbin/appdservice $1 $2
X		else
X			sudo -n $service_bin $1 $2
X		fi
X	fi
X}
X
Xfunction help()
X{
X	if [ -f README ] ; then
X		if [ -n "$PAGER" ] ; then
X			$PAGER README
X		else
X			cat README
X		fi
X	fi
X}
X
Xfunction stop_appdynamics_services()
X{
X	local secondary=$1
X	local errors=0
X	for s in ${appdynamics_service_list[@]}
X	do 
X		if [ -z "$secondary" ] ; then
X			service $s stop || ((errors++))
X		else
X			remservice -tq $secondary $s stop || ((errors++))
X		fi
X	done
X	return $errors;
X}
X
Xfunction verify_init_scripts()
X{
X	local secondary=$1
X	local ssh=`[ -n "$secondary" ] && echo "ssh -tq"`
X	local errors=0
X	local NEWMD5=
X	for s in ${appdynamics_service_list[@]}
X	do 
X		NEWMD5=`sed < $APPD_ROOT/HA/$s.sh \
X			-e "/^APPD_ROOT=/s,=.*,=$APPD_ROOT," \
X			-e "/^RUNUSER=/s,=.*,=$RUNUSER," | \
X			md5sum | cut -d " " -f 1`
X		if [[ "$NEWMD5" != `$ssh $secondary md5sum /etc/init.d/$s|cut -d " " -f 1` ]] ; then
X			((errors++))
X		fi
X	done
X	if [ $errors -gt 0 ] ; then
X		if [ -z $secondary ] ; then
X			echo "\
XOne or more AppDynamics init scripts are not installed or are out of date.
XPlease run $APPD_ROOT/HA/install-init.sh as root before proceeding."
X		else
X			echo "\
XOne or more AppDynamics init scripts are not installed or are out of date on
X$secondary.  Please run $APPD_ROOT/HA/install-init.sh as root on $secondary
Xbefore proceeding."
X		fi
X	fi
X	return $errors;
X}
X
Xfunction get_privilege_escalation(){
X	local secondary=$1
X	local ssh=`[ -n "$secondary" ] && echo "ssh -tq"`
X	local escalation_type=
X	local errors=0
X	for s in ${appdynamics_service_list[@]}
X	do 
X		if $ssh $secondary [ -x /sbin/appdservice ] ; then
X			if dd if=/sbin/appdservice bs=11 count=1 2>/dev/null \
X				| grep -q '^#!/bin/bash' ; then
X				escalation_type="pbrun"
X			else
X				escalation_type="setuid"
X			fi
X		else
X			$ssh $secondary sudo -nl $service_bin $s start > /dev/null 2>&1 || ((errors++))
X			$ssh $secondary sudo -nl $service_bin $s stop > /dev/null 2>&1 || ((errors++))
X			if  [ $errors -lt 1 ] ; then
X				escalation_type="sudo"
X			else
X				escalation_type="unknown"
X			fi
X		fi
X	done
X	echo $escalation_type
X	return $errors
X}
X
Xfunction verify_privilege_escalation(){
X	local secondary=$1
X	local errors=0
X	local local_priv_escalation=
X	local remote_priv_escalation=
X
X	local_priv_escalation=$(get_privilege_escalation)
X	if [ $? -gt 0 ] ; then
X		echo "\
XUser $RUNUSER is unable to start and stop appdynamics services
XPlease ensure that $APPD_ROOT/HA/install-init.sh has been run."
X		((errors++))
X	fi
X
X	remote_priv_escalation=$(get_privilege_escalation $secondary)
X	if [ $? -gt 0 ] ; then
X		echo "\
XUser $RUNUSER is unable to start and stop appdynamics services on $secondary.
XPlease ensure that $APPD_ROOT/HA/install-init.sh has been run on $secondary."
X		((errors++))
X	fi
X	
X	if [ $errors -lt 1 ] && [ "$local_priv_escalation" != "$remote_priv_escalation" ] ; then
X		echo "\
XThe primary and secondary hosts are not using the same privilege escalation
Xwrapper.
X
XPrimary:   $local_priv_escalation
XSecondary: $remote_priv_escalation
X
XPlease re-run install-init.sh on one or both hosts with the same options."
X		((errors++))
X	fi
X	return $errors
X}
X
Xfunction usage()
X{
X	echo "usage: $0 <options>"
X	echo "    -s <secondary hostname>"
X#	echo "    [ -j ] Synchronize controller app server configurations and related binaries"
X#	echo "           if secondary database is running, leave it running."
X	echo "    [ -e [protocol://]<external vip>[:port]"
X	echo "    [ -i [protocol://]<internal vip>[:port]"
X	echo "    [ -c <controller root directory> ]"
X	echo "       default: $def_APPD_ROOT"
X	echo "    [ -f ]       do final install and activation"
X	echo "    [ -t [rsync speed limit]]" if unspecified or 0, unlimited
X#	echo "    [ -u ] upgrade fixup"
X	echo "    [ -n ] no appserver start"
X	echo "    [ -w ] enable watchdog on secondary"
X	echo "    [ -z ] enable rsync compression"
X	echo "    [ -W ] use wildcard host in grant"
X	echo "    [ -h ] print help"
X	exit 1
X}
X
Xfunction parse_vip()
X{
X	vip_name=$1
X	vip_def=$2
X
X	echo $vip_def | awk -F: -v vip_name=$vip_name '
X		BEGIN { 
X			host=""; 
X			protocol="http";
X			port="8090"; 
X		}
X		/http[s]*:/ {protocol=$1; host=$2; port=$3;next}
X		/:/ {host=$1; port=$2;next}
X		{host=$1}
X		END {
X			gsub("^//","",host);
X			printf("%s_host=%s\n", vip_name, host);
X			printf("%s_port=%s\n", vip_name, port);
X			printf("%s_protocol=%s\n", vip_name, protocol);
X		}
X	'
X}
X
Xwhile getopts :s:e:i:c:dfhjut:nwzFHW flag; do
X	case $flag in
X	d)
X		debug=true
X		;;
X	s)
X		secondary=$OPTARG
X		;;
X	e)
X		external_vip=$OPTARG
X		;;
X	i)
X		internal_vip=$OPTARG
X		;;
X	j)
X		appserver_only_sync=true
X	    ;;
X	n)
X		start_appserver=false
X		;;
X	w)
X		watchdog_enable=true
X		;;
X	u)
X		upgrade=true
X		echo "upgrade currently unsupported"
X		exit 8
X		;;
X	:)
X		# optional arguments are handled here
X		if [ $OPTARG = 't' ] ; then
X			rsync_throttle=""
X		else
X			usage
X		fi
X		;;
X	t)
X		if echo $OPTARG | grep -q '^-' ; then
X			((OPTIND--))
X			OPTARG=0
X		fi
X		if [ $OPTARG -eq 0 ] ; then
X			rsync_throttle=""
X		else
X			rsync_throttle="--bwlimit=$OPTARG"
X		fi
X		;;
X	z)
X		rsync_compression="-z"
X		;;
X	c)
X		APPD_ROOT=$OPTARG
X		;;
X	F)
X		final=true
X		;;
X	W)
X		wildcard=true
X		;;
X	f)
X		echo "type 'confirm' to stop appserver and install HA"
X		read confirm
X		if [ "$confirm" != confirm ] ; then
X			exit 2;
X		fi
X		final=true
X	;;
X	h)
X		help
X		usage
X	;;
X	H|*)
X		if [ $flag != H ] ; then
X			echo "unknown option flag $OPTARG"
X		fi
X		usage
X	;;
X	esac
Xdone
X
Xif [ -z "$internal_vip" ] ; then
X	internal_vip=$external_vip
Xfi
X
Xeval `parse_vip external_vip $external_vip`
Xeval `parse_vip internal_vip $internal_vip`
X
X# sanity check - verify that the appd_user and the directory owner are the same
Xif [ `ls -ld .. | awk '{print $3}'` != `id -un` ] ; then
X	echo "Controller root directory not owned by current user"
X	exit 1
Xfi
X
Xif [ "$appserver_only_sync" == "true" ] && [ "$final" == "true" ] ; then
X	echo "\
XApp-server-only and final sync modes are mutually exclusive.  Please run with
X-j or -f, not both."
X	exit 1
Xfi
X
Xrequire "ex" "vim-minimal" "vim-tiny" || exit 1
Xrequire "rsync" "rsync" "rsync" || exit 1
Xif ! ssh $secondary "[[ -x $(which rsync) ]]" ; then
X   echo "rsync must be installed on $secondary"
X   exit 1
Xfi
X
Xif [ "$debug" == "true" ] ; then
X	if ! [[ -x `which parallel 2>&1` ]] ; then
X		echo "Gnu Parallel must be installed on the local host in order to enable debug mode"
X		debug="false"
X	fi
X	if ! ssh $secondary '[[ -x `which parallel 2>&1` ]]' ; then
X		echo "Gnu Parallel must be installed on $secondary in order to enable debug mode"
X		debug="false"
X	fi
X	if [ "$debug" == "false" ] ; then
X		exit 1
X	fi
Xfi
X
Xfunction cleanup() {
X	rm -rf $tmpdir
X}
X
Xtrap cleanup EXIT
Xcleanup
Xmkdir -p $tmpdir
X
Xfunction handle_interrupt(){
X	echo "Caught interrupt."
X	if [[ -n `jobs -p` ]] ; then
X		echo "Killing child processes."
X		kill $(jobs -p) 2>/dev/null
X	fi
X	echo "Exiting"
X	exit
X}
X
X# helper function to wrap up running, checking and possibly erroring a general shell command
Xfunction runcmd {
X	local cmd="$*"
X	if ! $cmd ; then
X		echo "\"$cmd\" command failed"
X		exit 1
X	fi
X}
X
Xtrap handle_interrupt INT
X
X#
X# set any variables dependent on command options
X#
Xrepl_log=$APPD_ROOT/logs/replicate.log
XWATCHDOG_ENABLE=$APPD_ROOT/HA/WATCHDOG_ENABLE
X#
X# if there's already a replicate log, rename the old one
X#
Xif [ -e $repl_log ] ; then
X	echo "  -- replication log renamed" `date` | tee -a $repl_log
X	mv $repl_log $repl_log.`date +%F.%T`
Xfi
X
X#
X# log versions and arguments
X#
Xecho "  -- replication log " `date` > $repl_log
Xecho -n "  -- version: " >> $repl_log 
Xgrep '$Id' $0 | head -1 >> $repl_log
Xecho "  -- command line options: " "$@" >> $repl_log
Xecho "  -- hostname: " `hostname` >> $repl_log
Xecho "  -- appd root: $APPD_ROOT" >> $repl_log
X
Xif [ ! -d "$APPD_ROOT" ] ; then
X	echo controller root $APPD_ROOT is not a directory | tee -a $repl_log
X	usage
Xfi
X
Xif [ -z "$secondary" ] ; then
X	echo secondary hostname must be set | tee -a $repl_log
X	usage
Xfi
X
X#
X# make sure we are running as the right user
X#
XRUNUSER=`awk -F= '/^[\t ]*user=/ {print $2}' $APPD_ROOT/db/db.cnf`
Xif [ -z "$RUNUSER" ] ; then
X        echo user not set in $APPD_ROOT/db/db.cnf | tee -a $repl_log
X        exit 1
Xfi
Xif [ `id -un` != "$RUNUSER" ] ; then
X	echo replicate script must be run as $RUNUSER | tee -a $repl_log
X	exit 1
Xfi
X
Xecho "  -- appdynamics run user: $RUNUSER" | tee -a $repl_log
X
X#
X# verify no-password ssh is set up
X#
Xecho "  -- assert no password ssh" | tee -a $repl_log
Xif ! ssh -o PasswordAuthentication=no -o StrictHostKeyChecking=no $secondary true ; then
X	echo "no-password ssh not set up" | tee -a $repl_log
X	exit 4
Xfi
X
X#
X# find a compatible cipher - important for speed
X#
Xfor ssh_crypto in aes128-gcm@openssh.com aes128-ctr aes128-cbc arcfour128 3des-cbc lose ; do
X	if ssh -c $ssh_crypto $secondary true >/dev/null 2>&1 ; then
X		break;
X	fi
Xdone
Xif [ "$ssh_crypto" = "lose" ] ; then
X	echo "  -- default crypto" | tee -a $repl_log
X	rsync_crypto=
Xelse
X	echo "  -- using $ssh_crypto crypto" | tee -a $repl_log
X	rsync_crypto="--rsh=ssh -c $ssh_crypto"
Xfi
X
X#
X# make sure we aren't replicating to ourselves!
X#
Xmyhostname=`hostname`
Xthemhostname=`ssh $secondary hostname 2>/dev/null`
X
Xif [ "$myhostname" = "$themhostname" ] ; then
X	echo "  -- self-replication meaningless"
X	exit 14
Xfi
X
Xdatadir=`grep ^datadir $APPD_ROOT/db/db.cnf | cut -d = -f 2`
Xinnodb_logdir=`grep ^innodb_log_group_home_dir $APPD_ROOT/db/db.cnf | cut -d = -f 2`
Xif [ -z "$innodb_logdir" ] ; then
X	innodb_logdir="$datadir"
Xfi
X
Xif [ "$appserver_only_sync" != "true" ] ; then
X
X	#
X	# sanity check: make sure we don't have the controller.sh interlock active.
X	# if there's no controller.sh file, we are the target of an incremental!
X	echo "  -- assert non-incremental" | tee -a $repl_log
X	if ! [ -f $APPD_ROOT/bin/controller.sh ] ; then
X		echo "copying from disabled controller - BOGUS!" | tee -a $repl_log
X		exit 15
X	fi
X
X	#
X	# make sure that the primary database is up.  if not, start it
X	#
X	if echo "exit" | $APPD_ROOT/bin/controller.sh login-db 2>&1 | grep -q "ERROR 2003" ; then
X		echo "  -- starting primary database" | tee -a $repl_log
X		$APPD_ROOT/bin/controller.sh start-db >> $repl_log 2>&1
X	fi
X
X	#
X	# make sure replication has stopped
X	#
X	echo "  -- stopping replication" | tee -a $repl_log
X	echo "STOP SLAVE;RESET SLAVE ALL;RESET MASTER;" | $APPD_ROOT/bin/controller.sh login-db >> $repl_log 2>&1
X
X	#
X	# sanity check: make sure we are not the passive side. replicating the
X	# broken half of an HA will be a disaster!
X	echo "  -- assert active side" | tee -a $repl_log
X	if echo "select value from global_configuration where name = 'appserver.mode'" | $APPD_ROOT/bin/controller.sh login-db | grep -q passive ; then
X		echo "copying from passive controller - BOGUS!" | tee -a $repl_log
X		exit 3
X	fi
X	
X	#
X	# force the ha.controller.type to primary, 
X	# this should kill the assassin if it running.
X	#
X	echo "  -- force primary" | tee -a $repl_log
X	echo "update global_configuration_local set value='primary' where name = 'ha.controller.type';" | $APPD_ROOT/bin/controller.sh login-db >> $repl_log
X
X	# stop the secondary database (and anything else)
X	# this may fail totally
X	#
X	echo "  -- stopping secondary db if present" | tee -a $repl_log
X	( stop_appdynamics_services $secondary || ssh $secondary $APPD_ROOT/bin/controller.sh stop ) >> $repl_log 2>&1
X
X	#
X	# the secondary loses controller.sh until we are ready
X	# this inhibits starting an incomplete controller
X	#
X	echo "  -- inhibit running of secondary and delete mysql/innodb logfiles" | tee -a $repl_log
X	ssh $secondary rm -f $APPD_ROOT/bin/controller.sh \
X		"$innodb_logdir/ib_logfile*"
X		"$datadir/*log*" \
X		$datadir/ibdata1 >> $repl_log 2>&1
X	
X	#
X	# disable automatic start of replication slave
X	#
X	echo "skip-slave-start=true" >> $APPD_ROOT/db/db.cnf
Xfi
X
X#
X# if final, make sure the latest init scripts are installed and stop the primary database
X#
Xif [ $final == 'true' ] ; then
X
X	# make sure the latest init scripts are installed on both hosts
X	if [ "$running_as_root" == "false" ] ; then
X		if ! verify_init_scripts; then
X			missing_init="true" 
X		fi
X		if ! verify_init_scripts $secondary ; then
X			missing_init="true"
X		fi
X		if [ "$missing_init" = "true" ] ; then
X			echo "Cannot proceed"
X			exit 7
X		fi
X		# verify that we can cause service state changes
X		if ! verify_privilege_escalation $secondary ; then
X			bad_privilege_escalation="true"
X		fi
X		if [ "$bad_privilege_escalation" = "true" ] ; then
X			echo "Cannot proceed"
X			exit 9
X		fi
X	else
X		$APPD_ROOT/HA/install-init.sh
X		ssh $secondary $APPD_ROOT/HA/install-init.sh
X	fi
X
X	echo "  -- stopping primary" | tee -a $repl_log
X	rsync_opts=$final_rsync_opts
X	rsync_throttle=""
X	( stop_appdynamics_services || $APPD_ROOT/bin/controller.sh stop ) >> $repl_log 2>&1
Xfi
X
X#
X# make sure the db.cnf is HA-enabled.  if the string ^server-id is not there,
X# then the primary has not been installed as an HA.
X#
Xecho "  -- checking HA installation" | tee -a $repl_log
Xif grep -q ^server-id $APPD_ROOT/db/db.cnf ; then
X	echo "  --   server-id present" | tee -a $repl_log
Xelse
X	echo "  --   server-id not present" | tee -a $repl_log
X	cat <<- 'ADDITIONS' >> $APPD_ROOT/db/db.cnf
X	# Replication -- MASTER MASTER (for HA installs) -- Should be appended 
X	# to the end of the db.cnf file for the PRIMARY controller.
X	binlog_cache_size=1M
X	max_binlog_cache_size=10240M
X	log_bin=bin-log
X	log_bin_index=bin-log.index 
X	relay_log=relay-log
X	relay_log_index=relay-log.index
X	innodb_support_xa=1
X	sync_binlog=0
X	log-slow-slave-statements
X	log-slave-updates
X	server-id=666  #  this needs to be unique server ID !!!
X	replicate-same-server-id=0
X	auto_increment_increment=10
X	auto_increment_offset=1
X	expire_logs_days=8
X	binlog_format=MIXED
X	replicate_ignore_table=controller.ejb__timer__tbl
X	replicate_ignore_table=controller.connection_validation
X	replicate_ignore_table=controller.global_configuration_local
X	replicate_wild_ignore_table=controller.mq%
X	replicate_wild_ignore_table=mysql.%
X	slave-skip-errors=1507,1517,1062,1032,1451
X	# added to speed up startup
X	innodb_stats_sample_pages=1
X	ADDITIONS
Xfi
X
X#
X# force server id - for failback
X#
Xex -s $APPD_ROOT/db/db.cnf <<- SETID
X/^server-id=/s,=.*,=666,
Xwq
XSETID
X
X#
X# make an empty directory on the secondary if needed
X#
Xecho "  -- mkdir if needed" | tee -a $repl_log
Xssh $secondary mkdir -p $APPD_ROOT >> $repl_log 2>&1 
Xssh $secondary mkdir -p $datadir >> $repl_log 2>&1 
X
X#
X# do a permissive chmod on the entire destination
X#
Xecho "  -- chmod destination" | tee -a $repl_log
Xssh $secondary "find $APPD_ROOT -type f -exec chmod +wr {} +" >> $repl_log 2>&1 
X
X#
X# check date on both nodes.  rsync is sensitive to skew
X#
Xecho "  -- checking clocks" | tee -a $repl_log
Xecho -n "primary date: " >> $repl_log
Xdate >> $repl_log 2>&1 
Xecho -n "secondary date: " >> $repl_log
Xssh $secondary date >> $repl_log 2>&1 
Xrmdate=`ssh $secondary date +%s`
Xlodate=`date +%s`
Xskew=$((rmdate-lodate))
Xif [ $skew -gt 60 ] || [ $skew -lt -60 ]; then
X	echo unacceptable clock skew: $rmdate $lodate $skew
X	exit 6
Xfi
Xecho "  --   clock skew: $skew" | tee -a $repl_log
X
Xif [ "$appserver_only_sync" == "true" ] ; then
X	echo "  -- Rsync'ing controller app server only: $APPD_ROOT" | tee -a $repl_log
X	rsync $rsync_opts "$rsync_crypto" $rsync_throttle $rsync_compression               \
X	    --exclude=app_agent_operation_logs/\*                          \
X		--exclude=db/\*                                                \
X		--exclude=logs/\*                                              \
X		--exclude=tmp\*                                                \
X		$APPD_ROOT/ $secondary:$APPD_ROOT >> $repl_log
X		echo "  -- Rsyncs complete" | tee -a $repl_log
X		echo "  -- App server only sync done" | tee -a $repl_log
X		exit 0
Xelse
X	#
X	# clean out the old relay and bin-logs
X	#
X	echo "  -- Removing old replication logs" | tee -a $repl_log
X	rm -f $datadir/bin-log* $datadir/relay-log* $datadir/master.info | tee -a $repl_log 2>&1
X	ssh $secondary "find $datadir -print | grep bin-log | xargs rm  -f" | tee -a $repl_log 2>&1
X	ssh $secondary "find $datadir -print | grep relay-log | xargs rm  -f" | tee -a $repl_log 2>&1
X	ssh $secondary rm -f $datadir/master.info | tee -a $repl_log 2>&1
X
X	#
X	# maximum paranoia:  build space ID maps of each of the innodb data files and prune differences
X	# caution: gnarly quoting
X	#
X	echo "  -- Building innodb file maps" | tee -a $repl_log
X	rm -f $tmpdir/ibdlist.local $tmpdir/ibdlist.remote
X	find $datadir/controller \
X		-name \*.ibd \
X		-exec sh -c 'echo -n {} ; od -j 40 -N 4 -t d4 -A none {}' \; | \
X		sort > $tmpdir/ibdlist.local
X
X	ssh $secondary "find $datadir/controller -name \*.ibd -exec sh -c 'echo -n {} ; od -j 40 -N 4 -t d4 -A none {}' \;" | sort > $tmpdir/ibdlist.remote
X
X	diff $tmpdir/ibdlist.local $tmpdir/ibdlist.remote | awk '/^>/ {print $2}' > $tmpdir/worklist
X	
X	discrepancies=`wc -w $tmpdir/worklist | awk '{print $1}'`
X	if [ $discrepancies -gt 0 ] ; then
X		printf "  --   found %d discrepancies\n" $discrepancies | tee -a $repl_log
X		cat $tmpdir/worklist | tee -a $repl_log
X		scp $tmpdir/worklist $secondary:/tmp/replicate-prune-worklist
X		ssh $secondary "cat /tmp/replicate-prune-worklist | xargs rm -f"
X	fi
X
X	#
X	# copy the controller + data to the secondary
X	#
X	echo "  -- Rsync'ing Controller: $APPD_ROOT" | tee -a $repl_log
X	rsync $rsync_opts "$rsync_crypto" $rsync_throttle $rsync_compression                \
X	    --exclude=bin/controller.sh					                    \
X	    --exclude=license.lic						                    \
X		--exclude=logs/\*							                    \
X		--exclude=db/data/\*                                            \
X		--exclude=db/bin/.status                                        \
X		--exclude=app_agent_operation_logs/\*                           \
X		--exclude=appserver/glassfish/domains/domain1/appagent/logs/\*  \
X		--exclude=tmp/\*                                                \
X		$APPD_ROOT/ $secondary:$APPD_ROOT >> $repl_log
X	echo "  -- Rsync'ing Data: $datadir" | tee -a $repl_log
X	rsync $rsync_opts "$rsync_crypto" $rsync_throttle $rsync_compression                \
X	    --exclude=bin-log\*						                        \
X	    --exclude=relay-log\*					                        \
X	    --exclude=\*.log						                        \
X	    --exclude=master.info                                           \
X	    --exclude=\*.pid                                                \
X	    --exclude=ib_logfile\*                                          \
X	    $datadir/ $secondary:$datadir >> $repl_log
X	echo "  -- Rsyncs complete" | tee -a $repl_log
Xfi
X
Xif [ "$final" == "true" ] ; then
X
X	if [ "$running_as_root" == "true" ] ; then
X		ssh $secondary $APPD_ROOT/HA/install-init.sh
X	fi
X
X	#
X	# make sure the machine agent, if installed, reports to the internal vip
X	# since we don't know where the machine agent is, look in a few likely places
X	#
X	for mif in $APPD_ROOT/MachineAgent/conf/controller-info.xml \
X			$APPD_ROOT/../MachineAgent/conf/controller-info.xml ; do
X		if [ -f $APPD_ROOT/MachineAgent/conf/controller-info.xml ] ; then
X			if [ -f "$mif" ] ; then
X				ex -s $mif <<- SETMACHINE
X					%s/\(<controller-host>\)[^<]*/\1$internal_vip_host/
X					%s/\(<controller-port>\)[^<]*/\1$internal_vip_port/
X					wq
X				SETMACHINE
X			fi
X		fi
X	done
Xfi
X
X#
X# always update the changeid - this marks the secondary
X#
Xcat > $tmpdir/ha.changeid <<- 'CHANGEID'
X/^server-id=/s,666,555,
Xwq
XCHANGEID
X
X#
X# edit the secondary to change the server id
X#
Xecho "  -- changing secondary server id" | tee -a $repl_log
Xcat $tmpdir/ha.changeid | ssh $secondary ex -s $APPD_ROOT/db/db.cnf >> $repl_log 2>&1
X
X#
X# if we're only do incremental, then no need to stop primary
X#
Xif [ $final == 'false' ] ; then
X	#
X	# validate init scripts and sudo config
X	# and warn user if they need to be updated before final
X	#
X	if [ "$running_as_root" == 'false' ] ; then
X		errors=0
X		verify_init_scripts || ((errors++))
X		verify_init_scripts $secondary || ((errors++))
X		if [ $errors -lt 1 ] ; then
X			verify_privilege_escalation $secondary
X		fi
X	fi
X	echo "  -- incremental sync done" | tee -a $repl_log
X	exit 0
Xfi
X
X#
X# plug the external hostname, protocol and port into the domain.xml
X#
Xif [ -n "$external_vip" ] ; then
X	echo "  -- edit domain.xml to point at external host" | tee -a $repl_log
X	if [ "$internal_vip_protocol" == "https" ] ; then
X		if grep -q appdynamics.controller.ssl.enabled $APPD_ROOT/appserver/glassfish/domains/domain1/config/domain.xml ; then
X			ex -s $APPD_ROOT/appserver/glassfish/domains/domain1/config/domain.xml <<- SETHTTPS
X				%s/\(-Dappdynamics.controller.ssl.enabled=\)[^<]*/\1true/
X			SETHTTPS
X		else
X			ex -s $APPD_ROOT/appserver/glassfish/domains/domain1/config/domain.xml <<- ADDHTTPS
X				/-Dappdynamics.controller.hostName/a
X				<jvm-options>-Dappdynamics.controller.ssl.enabled=true</jvm-options>
X				.
X			ADDHTTPS
X		fi
X	fi
X	ex -s $APPD_ROOT/appserver/glassfish/domains/domain1/config/domain.xml <<- SETHOST
X		%s/\(-Dappdynamics.controller.hostName=\)[^<]*/\1$internal_vip_host/
X		%s/\(-Dappdynamics.controller.port=\)[^<]*/\1$internal_vip_port/
X		%s/\(-Dappdynamics.controller.services.hostName=\)[^<]*/\1$internal_vip_host/
X		%s/\(-Dappdynamics.controller.services.port=\)[^<]*/\1$internal_vip_port/
X		%s,\(-Dappdynamics.controller.ui.deeplink.url=\)[^<]*,\1$external_vip_protocol://$external_vip_host:$external_vip_port,
X		wq
X	SETHOST
Xfi
X
X#
X# send the edited domain.xml
X#
Xecho "  -- copy domain.xml to secondary" | tee -a $repl_log
Xscp -p $APPD_ROOT/appserver/glassfish/domains/domain1/config/domain.xml $secondary:$APPD_ROOT/appserver/glassfish/domains/domain1/config/domain.xml >> $repl_log 2>&1
X
X#
X# write the primary hostname into the node-name property
X#
Xecho "  -- setting up controller agent on primary" | tee -a $repl_log
Xfor ci in $APPD_ROOT/appserver/glassfish/domains/domain1/appagent/conf/controller-info.xml \
X	$APPD_ROOT/appserver/glassfish/domains/domain1/appagent/ver*/conf/controller-info.xml ; do
X	ex -s $ci <<- SETNODE1
X		%s/\(<node-name>\)[^<]*/\1$primary/
X		wq
X	SETNODE1
Xdone
X
X#
X# write the secondary hostname into the node-name property
X#
Xecho "  -- setting up controller agent on secondary" | tee -a $repl_log
Xfor ci in $APPD_ROOT/appserver/glassfish/domains/domain1/appagent/conf/controller-info.xml \
X	$APPD_ROOT/appserver/glassfish/domains/domain1/appagent/ver*/conf/controller-info.xml ; do
X	ssh $secondary ex -s $ci <<- SETNODE2
X		%s/\(<node-name>\)[^<]*/\1$secondary/
X		wq
X	SETNODE2
Xdone
X
Xif [ "$debug" = "true" ] ; then
X	echo "  -- building file lists" | tee -a $repl_log
X	ls -1 $datadir/controller/* | parallel md5sum | sort -k 2 --buffer-size=10M > $APPD_ROOT/logs/filelist.primary &
X	ssh $secondary 'ls -1 '$datadir'/controller/* | parallel md5sum' | sort -k 2 --buffer-size=10M > $APPD_ROOT/logs/filelist.secondary &
X	wait
Xfi
X
X#
X# restart the primary db
X#
Xecho "  -- starting primary database" | tee -a $repl_log
X# Do not proceed unless the primary starts cleanly or we could end up with
X#  unexpected failovers.
Xif ! service appdcontroller-db start >> $repl_log 2>&1 ; then
X	echo "-- failed to start primary database.  Exiting..." | tee -a $repl_log
X	exit 1
Xfi
X
Xif [ -z $wildcard ] ; then
X	#
X	# let's probe the canonical hostnames from the local database
X	#
X	echo "  -- canonicalize hostnames" | tee -a $repl_log
X	primary1=`$APPD_ROOT/db/bin/mysql --host=$primary --port=$dbport --protocol=TCP --user=impossible 2>&1 | awk '
X		/ERROR 1045/ { gsub("^.*@",""); print $1;}
X		/ERROR 1130/ { gsub("^.*Host ",""); print $1;}' | tr -d \'`
X
X	secondary1=`ssh $secondary $APPD_ROOT/db/bin/mysql --host=$primary --port=$dbport --protocol=TCP --user=impossible 2>&1 | awk '
X		/ERROR 1045/ { gsub("^.*@",""); print $1;}
X		/ERROR 1130/ { gsub("^.*Host ",""); print $1;}' | tr -d \'`
X
X	#
X	# print the canonical hostnames
X	#
X	if [ "$primary1" = 'ERROR' -o "$secondary1" = 'ERROR' -o -z "$primary1" -o -z "$secondary1" ] ; then
X		echo "cannot establish communications between mysql instances" | tee -a $repl_log
X		echo "check firewall rules" | tee -a $repl_log
X		echo "primary: $primary1" | tee -a $repl_log
X		echo "secondary: $secondary1" | tee -a $repl_log
X		$APPD_ROOT/db/bin/mysql --host=$primary --port=$dbport --protocol=TCP --user=impossible 2>&1 | tee -a $repl_log
X		ssh $secondary $APPD_ROOT/db/bin/mysql --host=$primary --port=$dbport --protocol=TCP --user=impossible 2>&1 | tee -a $repl_log
X		exit 5
X	fi
X
X	[[ $primary1 != localhost ]] && primary=$primary1	# avoid issues with 127.0.0.1 having been set to hostname in /etc/hosts
X	[[ $secondary1 != localhost ]] && secondary=$secondary1	# avoid issues with 127.0.0.1 having been set to hostname in /etc/hosts
X	grant_primary=$primary
X	grant_secondary=$secondary
Xelse
X	grant_primary='%'
X	grant_secondary='%'
Xfi
X
Xecho "  -- primary: $primary" | tee -a $repl_log
Xecho "  -- secondary: $secondary" | tee -a $repl_log
X
X#
X# build the scripts
X#
X
Xcat >$tmpdir/ha.primary <<- PRIMARY
XSTOP SLAVE;
XRESET SLAVE ALL;
XRESET MASTER;
XGRANT ALL ON *.* TO 'controller_repl'@'$grant_secondary' IDENTIFIED BY 'controller_repl';
XFLUSH HOSTS;
XCHANGE MASTER TO MASTER_HOST='$secondary', MASTER_USER='controller_repl', MASTER_PASSWORD='controller_repl', MASTER_PORT=$dbport;
Xupdate global_configuration_local set value = 'active' where name = 'appserver.mode';
Xupdate global_configuration_local set value = 'primary' where name = 'ha.controller.type';
Xtruncate ejb__timer__tbl;
XPRIMARY
X
Xcat > $tmpdir/ha.secondary <<- SECONDARY
XSTOP SLAVE;
XRESET SLAVE ALL;
XRESET MASTER;
XGRANT ALL ON *.* TO 'controller_repl'@'$grant_primary' IDENTIFIED BY 'controller_repl'; FLUSH HOSTS;
XCHANGE MASTER TO MASTER_HOST='$primary', MASTER_USER='controller_repl', MASTER_PASSWORD='controller_repl', MASTER_PORT=$dbport;
Xupdate global_configuration_local set value = 'passive' where name = 'appserver.mode';
Xupdate global_configuration_local set value = 'secondary' where name = 'ha.controller.type';
Xtruncate ejb__timer__tbl;
XSECONDARY
X
Xcat > $tmpdir/ha.enable <<- 'DISABLE'
Xg/^skip-slave-start/d
Xwq
XDISABLE
X
X#
X# make all the changes on the primary to force master
X#
Xecho "  -- setting up primary slave" | tee -a $repl_log
Xcat $tmpdir/ha.primary | $APPD_ROOT/bin/controller.sh login-db >> $repl_log 2>&1
X
X#
X# now we need a secondary controller.sh
X#
Xecho "  -- copy controller.sh to secondary" | tee -a $repl_log
Xscp -p $APPD_ROOT/bin/controller.sh $secondary:$APPD_ROOT/bin >> $repl_log 2>&1
X
X#
X# but disable the appserver
X#
Xecho "  -- disable secondary appserver" | tee -a $repl_log
Xssh $secondary touch $APPD_ROOT/HA/APPSERVER_DISABLE >> $repl_log 2>&1
X
X#
X# make sure the master.info is not going to start replication yet, since it will be
X# a stale log position
X#
Xecho "  -- remove master.info" | tee -a $repl_log
Xssh $secondary rm -f $datadir/master.info >> $repl_log 2>&1
X
X#
X# start the secondary database
X#
Xecho "  -- start secondary database" | tee -a $repl_log
Xif ! remservice -t $secondary appdcontroller-db start >> $repl_log 2>&1 ; then
X	echo "could not start secondary database"
X	exit 10
Xfi
X
X#
X# ugly hack here - there seems to be a small timing problem
X#
Xecho "  -- wait for secondary to start" | tee -a $repl_log
Xuntil echo "show databases" | ssh $secondary $APPD_ROOT/bin/controller.sh login-db | grep -q "information_schema" ; do
X	echo `date` "waiting for mysql to start using $secondary" | tee -a $repl_log
X	sleep 2
Xdone
X
X#
X# make all the changes on the secondary
X#
Xecho "  -- setting up secondary slave" | tee -a $repl_log
Xcat $tmpdir/ha.secondary | ssh $secondary $APPD_ROOT/bin/controller.sh login-db >> $repl_log 2>&1
X
Xecho "  -- removing skip-slave-start from primary" | tee -a $repl_log
Xcat $tmpdir/ha.enable | ex -s $APPD_ROOT/db/db.cnf
Xecho "  -- removing skip-slave-start from secondary" | tee -a $repl_log
Xcat $tmpdir/ha.enable | ssh $secondary ex -s $APPD_ROOT/db/db.cnf
X
X#
X# start the replication slaves
X#
Xecho "  -- start primary slave" | tee -a $repl_log
Xecho "START SLAVE;" | $APPD_ROOT/bin/controller.sh login-db >> $repl_log 2>&1
X
Xecho "  -- start secondary slave" | tee -a $repl_log
Xecho "START SLAVE;" | ssh $secondary $APPD_ROOT/bin/controller.sh login-db >> $repl_log 2>&1
X
X#
X# slave status on both ends
X#
Xecho "  -- primary slave status " | tee -a $repl_log
Xecho "SHOW SLAVE STATUS\G" | \
X	$APPD_ROOT/bin/controller.sh login-db | \
X	awk '/Slave_IO_State/ {print}
X	/Seconds_Behind_Master/ {print} 
X	/Master_Server_Id/ {print}
X	/Master_Host/ {print}' | \
X	tee -a $repl_log 2>&1
Xecho "  -- secondary slave status " | tee -a $repl_log
Xecho "SHOW SLAVE STATUS\G" | \
X	ssh $secondary $APPD_ROOT/bin/controller.sh login-db | \
X	awk '/Slave_IO_State/ {print}
X	/Seconds_Behind_Master/ {print} 
X	/Master_Server_Id/ {print}
X	/Master_Host/ {print}' | \
X	tee -a $repl_log
X
X#
X# enable the watchdog, or not.
X#
Xif [ $watchdog_enable = "true" ] ; then
X	touch $WATCHDOG_ENABLE
X	ssh $secondary touch $WATCHDOG_ENABLE
Xelse
X	rm -f $WATCHDOG_ENABLE
X	ssh $secondary rm -f $WATCHDOG_ENABLE
Xfi
X
X#
X# handle license files - compare creation times, and use latest one
X# grab the one over there if newer
X#
Xremote_lic=0
Xlocal_lic=0
Xif ssh $secondary [ -f $APPD_ROOT/license.lic ] ; then
X	remote_lic=`ssh $secondary grep creationDate $APPD_ROOT/license.lic | \
X		 awk -F= '{print $2}'`
Xfi
Xif [ -f $APPD_ROOT/license.lic.$secondary ] ; then
X	local_lic=`grep creationDate $APPD_ROOT/license.lic.$secondary | \
X		awk -F= '{print $2}'`
Xfi
X
Xif [ $local_lic -lt $remote_lic ] ; then
X	echo "  -- copying license file from secondary" | tee -a $repl_log
X	scp $secondary:$APPD_ROOT/license.lic $APPD_ROOT/license.lic.$secondary 
Xelif [ $local_lic -ne 0 ] ; then
X	echo "  -- copying license file to  secondary" | tee -a $repl_log
X	scp $APPD_ROOT/license.lic.$secondary $secondary:$APPD_ROOT/license.lic
Xelse
X	echo "  -- secondary license file required" | tee -a $repl_log
Xfi
X
X#
X# handle odd case - license.lic.$primary is newer
X#
Xcopy_lic=0
Xlic=0
Xif [ -f $APPD_ROOT/license.lic ] ; then
X	lic=`grep creationDate $APPD_ROOT/license.lic | awk -F= '{print $2}'`
Xfi
Xif [ -f $APPD_ROOT/license.lic.$primary ] ; then
X	copy_lic=`grep creationDate $APPD_ROOT/license.lic.$primary | \
X		awk -F= '{print $2}'`
Xfi
X
Xif [ $lic -lt $copy_lic ] ; then
X	echo "  -- using newer $license.lic.$primary" | tee -a $repl_log
X	cp $APPD_ROOT/license.lic.$primary $APPD_ROOT/license.lic
Xelif [ $lic -ne 0 ] ; then
X	echo "  -- saving license to $license.lic.$primary" | tee -a $repl_log
X	cp $APPD_ROOT/license.lic $APPD_ROOT/license.lic.$primary
Xelse
X	echo "  -- no primary license file" | tee -a $repl_log
Xfi
X
Xecho "  -- sending primary license file" | tee -a $repl_log
Xscp $APPD_ROOT/license.lic.$primary $secondary:$APPD_ROOT
X
X#
X# now enable the secondary appserver
X#
Xecho "  -- enable secondary appserver" | tee -a $repl_log
Xssh $secondary rm -f $APPD_ROOT/HA/APPSERVER_DISABLE >> $repl_log 2>&1
X
X#
X# make sure host keys are properly set to prevent ssh from hanging
X#
Xecho "  -- checking for ssh access issues" | tee -a $repl_log
Xeval `echo "show slave status\G" | $APPD_ROOT/bin/controller.sh login-db |
X	awk 'BEGIN {OFS=""} /Master_Host/ {print "sechost=",$2}'`
Xeval `echo "show slave status\G" | ssh $secondary $APPD_ROOT/bin/controller.sh login-db |
X	awk 'BEGIN {OFS=""} /Master_Host/ {print "prihost=",$2}'`
Xruncmd ssh -o StrictHostKeyChecking=no $sechost ssh -o StrictHostKeyChecking=no $prihost /bin/true
X
X#
X# restart the appserver
X#
Xif [ $start_appserver = "true" ] ; then
X	echo "  -- start primary appserver" | tee -a $repl_log
X	if ! service appdcontroller start >> $repl_log 2>&1 ; then
X		echo "could not start primary appdcontroller service"
X		exit 12
X	fi
X
X	echo "  -- secondary service start" | tee -a $repl_log
X	# issues with the command actually starting the watchdog on the secondary.
X	# further troubleshooting needed
X	if ! remservice -t $secondary appdcontroller start >> $repl_log 2>&1; then
X		echo "could not start secondary appdcontroller service"
X		exit 11
X	fi
X	echo "  -- HA setup complete." | tee -a $repl_log
Xfi
X
END-of-replicate.sh
echo x - install-init.sh
sed 's/^X//' >install-init.sh << 'END-of-install-init.sh'
X#!/bin/bash
X#
X# $Id: install-init.sh 2.12 2015-12-23 00:36:28 cmayer $
X#
X# install init script
X#
XPBRUN=`grep PBRUN= appdservice-pbrun.sh | awk -F= '{print $2}'`
X
Xfunction usage {
X	echo "$0 -[options] where:"
X	echo "   -c  use setuid c wrapper"
X	echo "   -s  use sudo"
X	echo "   -p  use pbrun wrapper"
X	exit 1
X}
X
Xuse_pbrun=0
Xuse_cwrapper=0
Xuse_sudo=0
Xuse_root=0
X
Xwhile getopts cspr flag; do
X	case $flag in
X	c)
X		use_cwrapper=1
X		;;
X	s)
X		use_sudo=1
X		;;
X	p)
X		if [ -x $PBRUN ] ; then
X			use_pbrun=1
X		else
X			echo $PBRUN not found
X			exit 1
X		fi
X		;;
X	*)
X		usage
X		;;
X	esac
Xdone
X
Xif [ `id -u` != 0 ] ; then
X	echo $0 must be run as root
X	exit 0
Xfi
X
XSCRIPTNAME=$(basename $(readlink -e $0))
X
Xexport PATH=/sbin:/usr/sbin:$PATH
X
X# list of AppDynamics services in start order
XAPPDYNAMICS_SERVICE_LIST=( appdcontroller-db appdcontroller )
X
XVENDOR=`lsb_release -i 2>/dev/null | awk '{print $3}'`
X
Xif echo $VENDOR | grep -iq ubuntu ; then
X	#
X	# Define explicit start and stop order lists for Ubuntu and other distros
X	# were update-rc.d ignores the LSB dependency headers
X	#
X	APPDYNAMICS_SERVICE_START=( 90 91 )
X	APPDYNAMICS_SERVICE_STOP=( 90 89 )
Xfi
X
XAPPDSERVICE=/sbin/appdservice
X
Xcd $(dirname $0)
XAPPD_ROOT=`cd .. ; pwd`
Xif ! [ -d $APPD_ROOT/bin ] ; then
X	APPD_ROOT=/opt/AppDynamics/Controller
X	echo using default path $APPD_ROOT
Xfi
XDOMAIN_XML=$APPD_ROOT/appserver/glassfish/domains/domain1/config/domain.xml
X
XROOTOWNER=`ls -ld $APPD_ROOT | awk '{print $3}'`
XRUNUSER=`su -s /bin/bash -c "awk -F= '/^[\t ]*user=/ {print \\$2}' $APPD_ROOT/db/db.cnf" $ROOTOWNER`
Xif [[ `id -u $RUNUSER` != "0" ]] ; then
X	if [ `expr $use_cwrapper + $use_sudo + $use_pbrun` == 0 ] ; then
X		echo non-root usage requires at least one privilege escalation method
X		usage
X	fi
X	if [ `expr $use_cwrapper + $use_pbrun` == 2 ] ; then
X		echo cwrapper and pbrun are mutually exclusive
X		usage
X	fi
Xelse
X	use_root=1
Xfi
X
XCHKCONFIG=`which chkconfig 2>/dev/null`
XUPDATE_RC_D=`which update-rc.d 2>/dev/null`
XSERVICE=`which service 2>/dev/null`
X
Xfunction require() {
X	# args: executable "redhat package" "debian package" [ force|advise ] ["<reason package is required>"]
X	local errors=0
X	if ! [[  -x `which $1 2>/dev/null` ]] || [ "$4" == "force" ] ; then
X		if [[ -x `which apt-get 2>/dev/null` ]] ; then
X			if [ "$4" == "advise" ] ; then
X				echo "Package $3 not installed."
X				echo "$3 is required $5"
X				return 1
X			else
X				if ! apt-get -qq -y install $3 && [ "$4" == "force" ] ; then
X					errors=1
X				fi
X			fi
X		elif [[ -x `which yum 2>/dev/null` ]] ; then
X			if [ "$4" == "advise" ] ; then
X				echo "Package $2 not installed."
X				echo "$2 is required $5"
X				return 1
X			else
X				if ! yum --quiet -y install $2 >/dev/null && [ "$4" == "force" ] ; then
X					errors=1
X				fi
X			fi
X		fi
X		if ! [[  -x `which $1 2>/dev/null` ]] || [ "$errors" -gt 0 ] ; then
X			echo "Unable to install package containing $1"
X			return 1
X		fi
X	fi
X}
X
Xfunction install_init() {
X	echo "installing /etc/init.d/$1"
X	sed <./$1.sh >/etc/init.d/$1 \
X		-e "/^APPD_ROOT=/s,=.*,=$APPD_ROOT," \
X		-e "/^RUNUSER=/s,=.*,=$RUNUSER,"
X
X	chmod 0744 /etc/init.d/$1
X
X	if [ -x "$CHKCONFIG" ] ; then
X		chkconfig --add $1
X	elif [ -x "$UPDATE_RC_D" ] ; then
X		update-rc.d -f $1 remove 
X		update-rc.d $1 defaults $2 $3
X	else
X		echo "unsupported linux distribution: chkconfig or update-rc.d required"
X		exit 1
X	fi
X}
X
X#
X# make sure we have xmllint, bc, and the right version of ping installed
X#
Xmissing_dependencies=0
Xrequire xmllint libxml2 libxml2-utils || ((missing_dependencies++))
Xrequire bc bc bc || ((missing_dependecies++))
Xrequire ex vim-minimal vim-tiny || ((missing_dependecies++))
Xrequire curl curl curl || ((missing_dependencies++))
Xif ! ping -q -W 1 -c 1 localhost >/dev/null ; then
X	require ping iputils iputils-ping force || ((missing_dependencies++))
Xfi
Xif [ "$missing_dependencies" -gt 0 ] ; then
X	exit 1
Xfi
X
X#
X# since our RUNUSER isn't root, we want to make it so that sudo works
X# for our selected commands.   
X# this is not a security hole, it is a controlled privilege escalation, really.
X#
Xif [[ `id -u $RUNUSER` != "0" ]] ; then
X
X	if [ $use_sudo == 1 ] ; then
X		# Clean up C / pbrun wrappers if they were previously installed
X		rm -f $APPDSERVICE 2>/dev/null
X		require sudo sudo sudo || exit 1
X		[ -d /etc/sudoers.d ] || mkdir /etc/sudoers.d && chmod 0750 /etc/sudoers.d
X		grep -Eq "^#includedir[\t ]+/etc/sudoers.d[\t ]*$" /etc/sudoers || \
X		grep -Eq "^#include[\t ]+/etc/sudoers.d/appdynamics[\t ]*$" /etc/sudoers || \
X		echo "#include /etc/sudoers.d/appdynamics" >> /etc/sudoers
X		if [ -x "$CHKCONFIG" ] ; then
X			COMMA=
X			for s in ${APPDYNAMICS_SERVICE_LIST[@]} ; do
X				CMND_ALIAS_LIST="$CMND_ALIAS_LIST $COMMA \\
X				$SERVICE $s *, \\
X				$CHKCONFIG $s on, \\
X				$CHKCONFIG $s off"
X				COMMA=","
X			done
X		elif [ -x "$UPDATE_RC_D" ] ; then
X			COMMA=
X			for s in ${APPDYNAMICS_SERVICE_LIST[@]} ; do
X				CMND_ALIAS_LIST="$CMND_ALIAS_LIST$COMMA \\
X				$SERVICE $s *, \\
X				$UPDATE_RC_D $s enable, \\
X				$UPDATE_RC_D $s disable"
X				COMMA=","
X			done
X		fi
X		cat > /etc/sudoers.d/appdynamics <<- SUDOERS
X		# allow appdynamics user to:
X		#    start, stop, and query status of appdynamics via init scripts
X		#    to enable and disable those init scripts
X		Defaults:$RUNUSER !requiretty
X		Cmnd_Alias APPD = $CMND_ALIAS_LIST
X			$RUNUSER ALL=(root) NOPASSWD: APPD
X		SUDOERS
X		chmod 0440 /etc/sudoers.d/appdynamics
X		echo "installed /etc/sudoers.d/appdynamics"
X	fi
X
X	if [ $use_cwrapper == 1 ] ; then
X		if require cc gcc gcc advise "to build $APPDSERVICE privilege escalation wrapper" ; then
X			# Clean up sudo privilege escalation if it was previously installed
X			rm -f /etc/sudoers.d/appdynamics 2>/dev/null
X			# compile wrapper, chown and chmod with setuid
X			cc -D_GNU_SOURCE -DAPPDUSER=`id -u $RUNUSER` -o $APPDSERVICE appdservice.c
X			if [ -x $APPDSERVICE ] ; then
X				chown root:root $APPDSERVICE
X				chmod 4755 $APPDSERVICE
X				echo "installed setuid root wrapper as $APPDSERVICE"
X			else
X				echo "installation of $APPDSERVICE failed"
X			fi
X		else
X			echo "Exiting..."
X			exit 1
X		fi
X	fi
X
X	if [ $use_pbrun == 1 ] ; then
X		# Clean up sudo privilege escalation if it was previously installed
X		rm -f /etc/sudoers.d/appdynamics 2>/dev/null
X		# Install the pbrun privilege escalation wrapper
X		cp appdservice-pbrun.sh $APPDSERVICE
X		chmod 755 $APPDSERVICE
X		echo "installed pbrun wrapper as $APPDSERVICE"
X	fi
X
X	if [ $use_root == 1 ] ; then
X		# Clean up sudo privilege escalation if it was previously installed
X		rm -f /etc/sudoers.d/appdynamics 2>/dev/null
X		cp appdservice-root.sh $APPDSERVICE
X		chmod 755 $APPDSERVICE
X		echo "installed root wrapper as $APPDSERVICE"
X	fi
X
X	if ! require setcap libcap libcap2-bin && \
X		[[ `echo "cat //*[@port<1024]" | xmllint --shell $DOMAIN_XML | wc -l` -gt 1 ]] ; then
X		echo "\
XERROR: AppDynamics is configured to bind to at least one port < 1024 as an
Xunprivileged user, but the setcap utility is not available on this host.
XAppDynamics will not run in the configuration."
X		exit 1
X	fi
Xfi
X
X#
X# install all
X#
Xi=0
Xfor s in ${APPDYNAMICS_SERVICE_LIST[@]} ; do
X	install_init $s ${APPDYNAMICS_SERVICE_START[$i]} ${APPDYNAMICS_SERVICE_STOP[$i]}
X	((i++))
Xdone
END-of-install-init.sh
echo x - uninstall-init.sh
sed 's/^X//' >uninstall-init.sh << 'END-of-uninstall-init.sh'
X#!/bin/bash
X#
X# $Id: uninstall-init.sh 1.6 2015-12-23 00:36:28 cmayer $
X#
X# uninstall init script
X#
Xexport PATH=/sbin:/usr/sbin:$PATH
X
Xfunction remove() {
X	if [ ! -f /etc/init.d/$1 ] ; then
X		return
X	fi
X	if [[ -x `which chkconfig 2>/dev/null` ]] ; then
X		chkconfig --del $1
X	elif [[ -x `which update-rc.d 2>/dev/null` ]] ; then
X		update-rc.d -f $1 remove
X	else
X		echo "Failed to remove $1: chkconfig or update-rc.d required"
X		exit 1
X	fi
X	echo removing $1 service
X	rm -f /etc/init.d/$1
X}
X
Xremove appdcontroller
Xremove appdcontroller-db
X
Xif [ -f /sbin/appdservice ] ; then
X	echo removing appdservice wrapper
X	rm -f /sbin/appdservice
Xfi
X
Xif [ -f /etc/sudoers.d/appdynamics ] ; then
X	echo removing appdynamics specific sudoers file
X	rm -f /etc/sudoers.d/appdynamics
X
X	if grep -Eq "^#include[\t ]+/etc/sudoers.d/appdynamics[\t ]*$" /etc/sudoers ; then
X		echo removing sudoers additions
X		ex -s /etc/sudoers <<- RMAPPD
X			g/^#include[\t ][\t ]*\/etc\/sudoers.d\/appdynamics/d
X			wq
X		RMAPPD
X	fi
Xfi
END-of-uninstall-init.sh
echo x - appdservice.c
sed 's/^X//' >appdservice.c << 'END-of-appdservice.c'
X/*
X * $Id: appdservice.c 1.1 2015-06-12 12:22:17 cmayer $
X *
X * this program is a trampoline for the Appdynamics user to invoke
X * a controlled escalation of privilege to cause changes in the
X * installed appdynamics services via the system's service wrapper,
X * which is root-only
X *
X * security is ensured by only changing the enumerated services
X * and the enumerated funtions.  
X *
X * this file contains all the distro specific knowledge
X * it is intentionally coded in a brute-force manner to be trivially auditable
X *
X * all the source strings for the execv array are internal to this file, and
X * all the input arguments are only read using strcmp;  buffer overflows
X * are not possible.
X *
X * also, since we use execv, no path processing is done.
X */
X#include <stdlib.h>
X#include <stdio.h>
X#include <string.h>
X#include <unistd.h>
X#include <fcntl.h>
X
X/*
X * these names are intentionally not the same pointer, even though they have
X * the same value.
X * we never copy anything from the arguments to the exec arguments.
X */
Xstruct service {
X	char *name;
X	char *service_name;
X} services[] = {
X	{ "appdcontroller",		"appdcontroller" },
X	{ "appdcontroller-db",	"appdcontroller-db" },
X	{ "appdmachine_agent", 	"appdmachine-agent" }
X};
X#define NSRV (sizeof(services)/sizeof(services[0]))
X
X/* number of possible handlers */
X#define	NHAND	3
X
Xstruct action {
X	char *name;
X	struct handler {
X		char *prog;
X		char *verb;
X	} handlers[NHAND];
X} actions[] = {
X	{ "status", {
X		{ "service", "status" },
X		{ 0, 0 },
X		{ 0, 0 }}
X	},
X	{ "start", {
X		{ "service", "start" },
X		{ 0, 0 },
X		{ 0, 0 }}
X	},
X	{ "stop", {
X		{ "service", "stop" },
X		{ 0, 0 },
X		{ 0, 0 }}
X	},
X	{ "enable", {
X		{ "chkconfig", "on" },
X		{ "update-rc.d", "enable" },
X		{ 0, 0 }}
X	},
X	{ "disable", {
X		{ "chkconfig", "off" },
X		{ "update-rc.d", "disable" },
X		{ 0, 0 }}
X	}
X};
X#define NACT (sizeof(actions)/sizeof(actions[0]))
X
X/*
X * the complete list of directories for lookup of commands
X */
Xchar *bindirs[] = {
X	"/sbin", "/usr/sbin", 0
X};
X
Xvoid
Xusage(char *pname)
X{
X	int i, j;
X
X	fprintf(stderr, "usage: %s <service> <action>\n", pname);
X	for (i = 0; i < NSRV; i++) {
X		fprintf(stderr, "\t%s {", services[i].name);
X		for (j = 0; j < NACT; j++) {
X			fprintf(stderr, "%s", actions[j].name);
X			if (j < NACT - 1) {
X				fprintf(stderr, ",");
X			}
X		}
X		fprintf(stderr, "}\n");
X	}
X	exit (1);
X}
X
X/*
X * return zero if the program is executable in the specified directory
X */
Xint
Xexecutable_at(char *dir, char *prog)
X{
X	int dirfd;
X	int ret;
X
X	dirfd = open(dir, O_RDONLY | O_DIRECTORY);
X	ret = faccessat(dirfd, prog, AT_EACCESS, X_OK);
X	close(dirfd);
X	return (ret);
X}
X
Xchar *argvec[4];
Xchar *progpath;
X
Xint
Xmain(int argc, char**argv)
X{
X	char cmdbuf[80];
X	int svc;
X	int act;
X	int hand;
X	char *prog;
X	char *dir;
X	
X	if (argc != 3) {
X		usage(argv[0]);
X		exit (1);
X	}
X
X	/* look up service */
X	for (svc = 0; svc < NSRV; svc++) {
X		if (strcmp(services[svc].name, argv[1]) == 0) {
X			break;
X		}
X	}
X	if (svc >= NSRV) {
X		fprintf(stderr, "unknown service %s\n", argv[1]);
X		usage(argv[0]);
X	}
X
X	/* look up action */
X	for (act = 0; act < NACT; act++) {
X		if (strcmp(actions[act].name, argv[2]) == 0) {
X			break;
X		}
X	}
X	if (act >= NACT) {
X		fprintf(stderr, "unknown action %s\n", argv[2]);
X		usage(argv[0]);
X	}
X
X	/* validate that we are either the appdynamics user or root */
X	if (getuid() != APPDUSER && getuid() != 0) {
X		fprintf(stderr, "must be run as user id %d or root\n", APPDUSER);
X		exit(2);
X	}
X
X	/* validate that we are effectively root */
X	if (geteuid() != 0) {
X		fprintf(stderr, "must be run setuid root\n");
X		exit(3);
X	}
X	
X	/* definitively become root */
X	setreuid(0, 0);
X	setregid(0, 0);
X
X	/* iterate through handlers until null */
X	for (hand = 0; prog = actions[act].handlers[hand].prog; hand++) {
X
X		/* search the bindirs */
X		for (dir = bindirs[0]; dir; dir++) {
X
X			/* if we can run it, do so */
X			if (executable_at(dir, prog)) {
X
X				progpath = malloc(strlen(dir) + strlen(prog) + 2);
X				strcpy(progpath, dir);
X				strcat(progpath, "/");
X				strcat(progpath, prog);
X				argvec[0] = strdup(prog);
X				argvec[1] = strdup(services[svc].service_name);
X				argvec[2] = strdup(actions[act].handlers[hand].verb);
X				argvec[3] = 0;
X
X				execv(progpath, argvec);	
X			}
X		}
X	}
X
X	fprintf(stderr, "no valid handlers found for service %s action %s\n",
X		services[svc].name, actions[act].name);
X	exit(4);
X}
END-of-appdservice.c
echo x - appdservice-pbrun.sh
sed 's/^X//' >appdservice-pbrun.sh << 'END-of-appdservice-pbrun.sh'
X#!/bin/bash
X#
X# $Id: appdservice-pbrun.sh 1.1 2015-12-23 00:36:28 cmayer $
X#
X# shell wrapper around pbrun for appdynamics service changes
X#
XPBRUN=/usr/local/bin/pbrun
X
Xfunction usage {
X	echo usage: "$0 [appdcontroller appdcontroller-db] [start stop status]"
X	exit 1
X}
X
Xif [ ! -x $PBRUN ] ; then
X	echo $0: pbrun not found at $PBRUN
X	exit 2
Xfi
X
Xif [ $# -ne 2 ] ; then
X	usage
Xfi
X
Xcase $1 in
X	appdcontroller|appdcontroller-db)
X		service=$1
X		;;
X	*)
X		usage
X		;;
Xesac
X
Xcase $2 in
X	start|stop|status)
X		action=$2
X		;;
X	*)
X		usage
X		;;
Xesac
X
X$PBRUN -b /sbin/service $service $action
Xexit 0
END-of-appdservice-pbrun.sh
echo x - appdservice-root.sh
sed 's/^X//' >appdservice-root.sh << 'END-of-appdservice-root.sh'
X#!/bin/bash
X#
X# $Id: appdservice-root.sh 1.1 2015-12-23 00:36:28 cmayer $
X#
X# shell wrapper around service for service changes - designed to run as root
X#
Xfunction usage {
X	echo usage: "$0 [appdcontroller appdcontroller-db] [start stop status]"
X	exit 1
X}
X
Xif [ $# -ne 2 ] ; then
X	usage
Xfi
X
Xcase $1 in
X	appdcontroller|appdcontroller-db)
X		service=$1
X		;;
X	*)
X		usage
X		;;
Xesac
X
Xcase $2 in
X	start|stop|status)
X		action=$2
X		;;
X	*)
X		usage
X		;;
Xesac
X
X/sbin/service $service $action
Xexit 0
END-of-appdservice-root.sh
echo x - hafunctions.sh
sed 's/^X//' >hafunctions.sh << 'END-of-hafunctions.sh'
X#!/bin/bash
X#
X# $Id: hafunctions.sh 1.2 2015-06-12 12:22:17 cmayer $
X#
X# hafunctions.sh
X# contains common code used by the HA toolkit
X# 
END-of-hafunctions.sh
echo x - RUNBOOK
sed 's/^X//' >RUNBOOK << 'END-of-RUNBOOK'
XThe HA environment can be in several states, and it is desireable to place 
Xthe systems into the fully replicated state as soon as possible. here are
Xthe possible states, how to identify the state, and the corresponding 
Xprocedure to repair the condition.
X
X-----------
XNOT PRESENT:
X	the HA package has not been installed on the primary machine.
X
Xdiagnosis:
X	the HA directory is absent from the controller directory.
X
Xto fix:
X	cd <controller root> ; mkdir HA ; cd HA ; bash <path>/HA.shar
X	then follow the steps for UNINSTALLED
X
X-----------
XUNINSTALLED:
X	the package is present in the controller HA directory, but the
X	services have not been installed.
X
Xdiagnosis:
X	service appdcontroller status shows appdcontroller service not found
X
Xto fix:
X	cd <controller root>/HA
X	become root
X	./install-init.sh
X
X------------
XNO HOSTS:
X	the secondary machine does not have a resolvable host name
X
Xdiagnosis:
X	ping <secondary> returns unknown host
X
Xto fix:
X	add the primary and secondary host name into both machines /etc/hosts files
X	
X------------
XNO SSH:
X	the appdynamics user does not have no-password ssh access between
X	machines.
X
Xdiagnosis:
X	ssh <secondary> date prompts for a password
X
Xto fix:
X	in the below, you will be prompted for passwords and confirmations
X	ssh-keygen -P "" -f ~/.ssh/id_rsa -t rsa
X	ssh <secondary> ssh-keygen -P "''" -f ~/.ssh/id_rsa -t rsa
X	scp ~/.ssh/id_rsa.pub <secondary>:.ssh/authorized_keys
X	scp <secondary>:.ssh/id_rsa.pub ~/.ssh/authorized_keys
X
X------------
XUNREPLICATED: the HA package has been installed on the primary controller,
Xbut the package has not been activated.
X
Xdiagnosis:
X	service appdcontroller-db status shows "HA not installed" 
X
Xto fix:
X	cd <controller root>/HA
X	./replicate -s <secondary>
X	<become root on secondary>
X		cd <controller root>/HA
X		./install-init
X		exit
X	<back on primary>
X	./replicate -s <secondary> -e <vip>	-f
X		confirm
X
X----------
XDISCONNECTED:
XReplication communication is being blocked, HA has been installed and activated,
Xbut a firewall is preventing access to replication communications.
X
Xdiagnosis:
X	service appdcontroller-db status shows 
X		"Slave_IO_State: Connecting to master"
X		"Seconds_Behind_Master: NULL"
X
Xto fix:
X	disable the firewall for port 3388
X	brute force as root:  iptables -F
X
X----------
XREPLICATED, WATCHDOG RUNNING: 
Xthe HA package is running fully replicated, and the primary node is serving
Xagents with metric storage, and the UI is responsive.  the secondary is
Xmonitoring the primary appserver with a watchdog process.
X
Xdiagnosis:
X	service appdcontroller status on the primary reports:
X	db running as <user> - active
X	primary
X		Slave_IO_State: Waiting for master to send event
X	controller running
X
X	service appdcontroller status on the secondary reports:
X	db running as <user> - passive
X	secondary
X		Slave_IO_State: Waiting for master to send event
X	watchdog running
X
Xto fix:
X	nothing to fix
X
X----------
XREPLICATED, WATCHDOG NOT RUNNING: 
Xthe HA package is running fully replicated, and the primary node is serving
Xagents with metric storage, and the UI is responsive.  the secondary is
Xnot monitoring the primary appserver with a watchdog process.
X
Xdiagnosis:
X	service appdcontroller status on the primary reports:
X	db running as <user> - active
X	primary
X		Slave_IO_State: Waiting for master to send event
X	controller running
X
X	service appdcontroller status on the secondary reports:
X	db running as <user> - passive
X	secondary
X		Slave_IO_State: Waiting for master to send event
X	watchdog not running
X
Xto fix:
X	on the secondary
X	cd <controller root>/HA
X	touch WATCHDOG_ENABLE
X	/sbin/appdservice appdcontroller start
X
X---------
XFAILED OVER, old primary broken
XThe current active node has become active because of a failover.  the prior
Xactive node's database is inaccessible.  the assassin is running on the new
Xactive node to mark the old active node passive once it comes up.
X
Xdiagnosis:
X	service appdcontroller status on the primary reports:
X	db running as <user> - active
X	secondary
X		Slave_IO_State:
X		Seconds_Behind_Master: NULL
X	assassin running
X
Xto fix:
X	replicate from the new active node to the old active node using
X	the formula for UNREPLICATED
X
X------------
XFAILED OVER, watchdog running
XThe current active node has become active because of a failover.  the prior
Xactive node database is still intact, and replication is valid. the new
Xsecondary node has a watchdog running.  this is identical to the REPLICATED,
XWATCHDOG_RUNNING state.
X
Xdiagnosis:
X	service appdcontroller status on the original primary reports:
X	db running as <user> - passive
X		Slave_IO_State: Waiting for master to send event
X	secondary
X	watchdog running
X
X	service appdcontroller status on the original secondary reports:
X	db running as <user> - active
X	primary
X		Slave_IO_State: Waiting for master to send event
X	controller running
X
Xto-fix:
X	no need to fix anything.  should it be desired to make the original node
X	the active node:
X
X	on the original primary,
X	cd <controller root>/HA
X	./failover.sh
X
X-------------
XPASSIVE DOWN
Xthis is a state deliberately caused to perform a consistent backup of the
Xdatabase.   it is initiated on the passive node by running:
X/sbin/appdservice appdcontroller-db stop
X
Xdiagnosis:
X	/sbin/appdservice appdcontroller-db status on the passive node reports:
X	db not running
X
Xto-fix:
X	on the passive controller,
X	/sbin/appdservice appdcontroller start
X
XVersion:
X--------
X$Id: RUNBOOK 1.2 2015-12-23 00:36:28 cmayer Exp $
X
END-of-RUNBOOK
chmod ugo+rx . .. *.sh; exit

